<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[部署]Capistrano: 自动化部署的利器</title>
    <url>/2016/12/10/Capistrano:%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<p>Capistrano: 自动化部署的利器</p>
<p>注意： 以下的文档针对的版本是 2.12.0 capistrano 3.x 跟 2.x 的工作原理是差不多的. 掌握了其中一个, 就可以很快掌握第二个. 区别在于 3.x 只在 ruby 2.x 版本下工作. 很多项目都是 1.9.x的,所以我们以capistrano 2为例.</p>
<p>简介</p>
<p>Capistrano 是个好用的自动化部署工具, 能够快速自动的将自己的代码部署到正式服务器上面。 替代人肉的工作.</p>
<p>注意: (TODO 另起个章节,专门说安全问题)</p>
<p>绝对不要把 config&#x2F;deploy.rb 放到代码仓库中. 绝对不要把 config&#x2F;deploy.rb 放到代码仓库中. 绝对不要把 config&#x2F;deploy.rb 放到代码仓库中.</p>
<p>同理, 不要把 配置信息 放到 代码仓库中. 比如:</p>
<p>数据库配置信息: database.yml 邮箱配置信息: mail.yml 应用服务器配置信息: thin.yml, unicorn.yml</p>
<p>如果你在公司中发现这样的人,直接把他开掉. 对服务器没有安全意识.</p>
<p>无数的服务器配置信息,都在github上的公共项目中的 部署脚本 文件中泄漏出去的. 端口号, 用户名, ip地址一泄漏出去的话,基本上对方拿个密码字典碰几天, 你的服务器就成了肉鸡了.</p>
<p>为什么不要人肉去做</p>
<p>很多同学在部署时,用的是自己写的脚本. 这个就不对了. 自己写的脚本永远不专业. 不要自大,相信我没错的.</p>
<p>哪怕是运维级别的同学,写出来的脚本,也无法轻易回滚. 因为这里的逻辑还是比较多的,光靠脚本不行. 还得 需要比较多的代码逻辑.</p>
<p>最常见的人肉脚本是:</p>
<p>进入到代码仓库<br>$ cd &lt; your code repo&gt;<br>更新代码:<br>$ git pull<br>重启<br>$ bundle exec thin restart<br>如果你有20个服务器,就可以这样使用脚本去做了.</p>
<p>但是上面最大的缺点:</p>
<p>无法回滚<br>你要祈祷工作顺风顺水,稍微有一个环节出了错, 就要手续继续处理剩下的环节.<br>安装方式：</p>
<p>进入到项目目录下面,并增加下面内容到 Gemfile 中：<br>group :development<br>  gem ‘capistrano’, ‘2.12.0’<br>  gem ‘capistrano-rbenv’, ‘1.0.1’<br>end<br>安装添加的gem<br>$ bundle install<br>再运行下面的命令：<br>$ capify .<br>capify .<br>[skip] ‘.&#x2F;Capfile’ already exists<br>[skip] ‘.&#x2F;config&#x2F;deploy.rb’ already exists<br>[done] capified!<br>会生成两个关键性的文件： Capfile , config&#x2F;deploy.rb</p>
<p>编辑后者config&#x2F;deploy.rb 加上自己的capistrano配置信息<br>启动deploy中的setup任务,创建一些必要文件夹<br>下面是一个完整的 部署脚本( config&#x2F;deploy.rb )的例子, 修改其中的 用户名,端口号, 目标服务器的域名 , 服务器的启动方式, 就可以直接运行了.:</p>
<h1 id="encoding-utf-8"><a href="#encoding-utf-8" class="headerlink" title="-- encoding : utf-8 --"></a>-<em>- encoding : utf-8 -</em>-</h1><p>require ‘capistrano-rbenv’<br>load ‘deploy&#x2F;assets’<br>SSH_USER &#x3D; ‘你的用户名’<br>SSH_PORT &#x3D; ‘你的端口号’<br>server &#x3D; “目标服务器的域名或者ip”<br>FOLDER_IN_REMOTE_SERVER &#x3D; ‘远程服务器上的目标文件夹’</p>
<p>ssh_options[:port] &#x3D; SSH_PORT<br>set :rake, “bundle exec rake”<br>set :application, “app name”<br>set :repository, “.”<br>set :scm, :none<br>set :deploy_via, :copy</p>
<p>role :web, server<br>role :app, server<br>role :db,  server, :primary &#x3D;&gt; true<br>role :db,  server</p>
<p>set :deploy_to, FOLDER_IN_REMOTE_SERVER<br>default_run_options[:pty] &#x3D; true</p>
<h1 id="change-to-your-username"><a href="#change-to-your-username" class="headerlink" title="change to your username"></a>change to your username</h1><p>set :user, SSH_USER</p>
<p>namespace :deploy do<br>  task :start do<br>    run “cd #{release_path} &amp;&amp; bundle exec thin start -C config&#x2F;thin.yml”<br>  end<br>  task :stop do<br>    run “cd #{release_path} &amp;&amp; bundle exec thin stop -C config&#x2F;thin.yml”<br>  end<br>  task :restart, :roles &#x3D;&gt; :app, :except &#x3D;&gt; { :no_release &#x3D;&gt; true } do<br>    db_migrate<br>    stop<br>    sleep 2<br>    start<br>  end<br>  task :db_migrate do<br>    run “cd #{release_path} &amp;&amp; bundle install”<br>    run “cd #{release_path} &amp;&amp; bundle exec rake db:migrate RAILS_ENV&#x3D;production”<br>  end</p>
<p>  namespace :assets do<br>    task :precompile do<br>      #run “bundle install”<br>      #run “cd #{release_path} &amp;&amp; bundle exec rake RAILS_ENV&#x3D;production RAILS_GROUPS&#x3D;assets assets:precompile “<br>    end<br>  end<br>end</p>
<p>desc “Copy database.yml to release_path”<br>task :cp_database_yml do<br>  puts “&#x3D;&#x3D;&#x3D; executing my customized command: “<br>  run “cp -r #{shared_path}&#x2F;config&#x2F;* #{release_path}&#x2F;config&#x2F;“<br>  run “ln -s #{shared_path}&#x2F;files #{release_path}&#x2F;public&#x2F;files”</p>
<h1 id="因为在开发机器上会存在这个文件夹，所以需要先把它删掉，再-ln"><a href="#因为在开发机器上会存在这个文件夹，所以需要先把它删掉，再-ln" class="headerlink" title="因为在开发机器上会存在这个文件夹，所以需要先把它删掉，再 ln"></a>因为在开发机器上会存在这个文件夹，所以需要先把它删掉，再 ln</h1><p>  run “rm #{release_path}&#x2F;public&#x2F;uploads -rf”<br>  run “ln -s #{shared_path}&#x2F;public&#x2F;uploads #{release_path}&#x2F;public&#x2F;uploads”<br>  puts “&#x3D;&#x3D;&#x3D; done (executing my customized command)”<br>end</p>
<p>before “deploy:assets:precompile”, :cp_database_yml<br>#after “deploy”, “deploy:restart”<br>第一次运行时,要先 配置好目标服务器上的文件夹.</p>
<p>$ cap deploy:setup<br>注意: 这里让它创建基本的目标文件夹目录层次就可以:</p>
<p>&#x2F;opt&#x2F;app:<br>    current (这是个软链接 soft link, )-&gt; &#x2F;opt&#x2F;app&#x2F;releases&#x2F;20150518030114&#x2F;<br>    releases&#x2F;<br>    shared&#x2F;<br>        assets<br>        config<br>        files<br>        log<br>        pids<br>        public<br>        system<br>不要让它做 : 安装rbenv, 安装ruby 版本, 安装第三方包的事儿.</p>
<p>注意： 这里务必记得， 盯紧控制台的输出， 看到它执行完 mkdir -p 之后， 赶紧按ctrl + c 暂停。否则它会默认在远程服务器上安装各种ruby 第三方包，安装各种linux 依赖包。一不小心就会把服务器环境搞砸了。</p>
<p>为 shared 目录下，增加各种配置文件，它们只需要被配置一遍。例如：<br>config&#x2F;thin.yml       # 服务器的配置<br>config&#x2F;database.yml   # 数据库的配置<br>config&#x2F;log4r.yml      # 日志文件的配置<br>config&#x2F;settings.yml   # 系统的配置<br>配置好ruby环境， mysql, thin, nginx 等<br>开始部署</p>
<p>$ cap deploy.<br>这个命令会执行下面的过程:</p>
<p>准备启动服务器:<br>安装各种新增的rubygem<br>做必要的数据库迁移<br>配置各种文件<br>修改上传文件夹的softlink<br>其他,每次使用裸代码做部署的时候,都要人肉做的事情. (修改保存日志的路径, 修改 rails server的配置, )<br>编译,压缩 js&#x2F; css<br>重启 服务器( $ nginx -s reload, $ kill -9 xxx , $ thin start -C config&#x2F;thin.yml)<br>再次部署（更新版本）</p>
<p>只需要运行$ cap deploy即可。</p>
<p>使用命令行</p>
<p>下面是一个例子，在命令行中显示 User name: , 等用户输入完，按回车之后， 把输入的值赋给 user 变量。</p>
<p>set(:user) { Capistrano::CLI.ui.ask(“User name: “) }<br>使用帮助：<br>$ cap –help<br>使用logger，特别是在其他语言调用CAP时，非常有用（例如被fabric 调用）:<br>$ cap setup –logger STDOUT<br>如何使用变量?<br>要记得: 使用@. . 例如，我们要设置 “deploy_type” 这个变量：</p>
<p>$ cap say_hi –set-before deploy_type&#x3D;staging<br>然后在 config&#x2F;deploy.rb 中这样使用：</p>
<p>DEFAULT_TYPE &#x3D; “stable”</p>
<h1 id="deploy-type-仅仅在-begin-这个区域中生效-在rescue-ensure中都不行。"><a href="#deploy-type-仅仅在-begin-这个区域中生效-在rescue-ensure中都不行。" class="headerlink" title="deploy_type 仅仅在 begin 这个区域中生效, 在rescue, ensure中都不行。"></a>deploy_type 仅仅在 begin 这个区域中生效, 在rescue, ensure中都不行。</h1><p>begin<br>  deploy_type<br>  puts “deploy_type was set successfully”<br>  @deploy_type &#x3D; deploy_type<br>  rescue Exception &#x3D;&gt; e<br>  puts “deploy_type not set, use default: #{DEFAULT_TYPE}”<br>  deploy_type &#x3D; DEFAULT_TYPE<br>  @deploy_type &#x3D; deploy_type<br>end</p>
<p>task :say_hi do<br>  puts “hihihi, var_deploy_type: #{@deploy_type}”<br>end<br>输出：</p>
<p>deploy_type was set successfully<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; DEPLOY_PATH: &#x2F;rails_apps&#x2F;babble_portal&#x2F;cutting_edge</p>
<ul>
<li>executing &#96;say_hi’<br>hihihi, var_deploy_type: 444<br>最后，使用copy方式：</li>
</ul>
<h1 id="脚本中"><a href="#脚本中" class="headerlink" title="脚本中"></a>脚本中</h1><p>set :scm, :none<br>set :repository, “.”<br>set :deploy_via, :copy<br>capistrano的输出详解</p>
<p>TODO 各种屏幕截图。 建立文件夹， 打包，压缩，上传，解压缩， rake db.. assets等等</p>
<p>为什么要用capistrano</p>
<p>流行的工具都是有道理的（ best practices are best in most cases)</p>
<p>版本控制：SVN &#x3D;&gt; GIT( scm : from SVN to GIT)</p>
<p>部署方式：人肉部署 &#x3D;&gt; Capistrano</p>
<p>原来项目中用到的是SVN， 就一个分支，也不打tag。感觉用起来没啥。 ( there’s not so much trouble when the project is going under SVN and manual deployment)</p>
<p>现在服务器的配置被运维同学限制了，无法连到SCM服务器 (同时无法连接到外网，无法连接到很多内部网络，比如LDAP，RADIUS等等）。肿么办???? (but one day, the server was limited its access to the internet, git repo and local LDAP , Radius service… what shall we do? )</p>
<p>如果用SVN的话，就得用SCP的方式，打包过去，然后修修改改，每次都要人肉来做，还出错。(if using SVN, we have to copy the entire code folder to the target server, easy to make mistake and really painful for me )</p>
<p>现在换成了GIT，不用capistrano的话，直接在本地把 git-patch 上传过去，然后 git am 就好。(now since we have migrated the SVN to GIT repo, it’s very easy to achieve the same goal using ‘git-patch’ and ‘git am’ )</p>
<p>用了capistrano的话，用 deploy_via :scp 的 方式，我每次部署一行命令，自动搞定了。 ( and in capistrano, we just need to use ‘deploy_via scp’ to do the deployment job )</p>
<p>所以，老式的办法，在某些新问题出现的时刻，不是那么得心应手。业界流行的“最佳实践”，在大部分情况下，还是“最佳实践”的。 ^_^ ( the conclusion is: best practices are always best in most cases. )</p>
<p>—— 学习是王道！ ( keep STUDYING everyday! )</p>
<p>capistrano的原理</p>
<p>裸代码: 没有数据库的配置文件, 没有服务器相关的配置文件, 也没有压缩各种css&#x2F;js , 一般都是从git上直接clone下来的代码。</p>
<p>传统的部署步骤:</p>
<p>ssh 登陆到服务器<br>git pull<br>restart command（重新启动）<br>坏处是:</p>
<p>无法回滚,<br>每次都人肉, 特别麻烦.<br>虽然上面3个步骤看似很少, 但是需要一直盯着(比如, ssh 需要10秒, git pull 需要20秒, restart 也需要人肉输入, 这些都是时间上的损耗, 而且人肉做重复性的事情, 无趣, 容易出错。</p>
<p>合理的部署是:</p>
<p>编写好一个配置文件之后, 运行代码: $ cap deploy (一个命令) , 之后的所有事情,都不用人参与了。</p>
<p>结构:</p>
<p>有三个角色:部署人员的机器,目标服务器,代码服务器(GIT)</p>
<p>TODO: 没xuan的图片</p>
<p>( 见譞的本本上的图 )</p>
<p>每次部署, 都要做的事情:</p>
<p>SSH 到目标服务器<br>把最新的代码,上传到目标服务器上。这时候的代码是裸代码，不能立刻部署, 因为很多配置文件都没有。</p>
<p>我们不能把配置文件也放到github里面跟踪, 比如: config&#x2F;database.yml , 每个人或服务器的数据库的 mysql 密码都不一样。</p>
<p>以及其他的内容(上传文件夹)</p>
<p>项目的回滚</p>
<p>回滚的方式有几种:</p>
<p>code roll back</p>
<p>git checkout … 这样不好,很多时候我们无法保证代码是没有被修改的。 被修改之后, checkout操作会涉及到代码合并的情况, 在某些 紧急 BUG 出现时, 会特别明显.</p>
<p>使用capistrano,将上一次的release回滚,每一个release都用一个文件夹(里面包含了完整的项目代码, 包括裸代码, 和 各种配置文件)。</p>
<p>目录结构</p>
<p>20150310010954, 20150319015536 这种时间戳命名的文件夹，代码某一个时间段部署的版本。</p>
<p>有一个特殊的softlink(软链接),current。</p>
<p>web服务器的nginx配置,thin配置可以指向这个softlink,这样就不需要每次都改nginx，thin 的配置文件了, 只需要把current这个softlink,重新指向不同的 release 文件夹就可以了。</p>
<p>shared文件夹中所保存的内容, 以及部分目录结构, 是由 config&#x2F;deploy.rb 这个配置文件决定的</p>
<p>capistrano部署web应用的文件结构是:</p>
<p>&#x2F;opt&#x2F;rails_app:<br>    current -&gt; &#x2F;opt&#x2F;app&#x2F;happystock_web&#x2F;releases&#x2F;20150518030114&#x2F;<br>    releases&#x2F;<br>        20150310010954<br>        20150319015536<br>        20150518030114<br>    shared&#x2F;<br>        assets<br>        config<br>        files<br>        log<br>        pids<br>        public<br>        system<br>常见问题</p>
<p>无法部署capistrano? Net::SSH::AuthenticationFailed: Authentication failed</p>
<p>对于capistrano 2.12.0,显式指定Gemfile中net-ssh 的版本，例如：</p>
<p>gem ‘net-ssh’, ‘2.7.0’<br>下面是一个完整的deploy.rb文件：</p>
<p><a href="https://github.com/beijing-rubyist/bjrubyist/blob/master/config/deploy.rb">https://github.com/beijing-rubyist/bjrubyist/blob/master/config/deploy.rb</a></p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
  </entry>
  <entry>
    <title>[Android]整合H5的WebView(微信支付，支付宝支付)</title>
    <url>/2016/10/19/Android%E6%95%B4%E5%90%88H5/</url>
    <content><![CDATA[<p>Android整合H5(vuejs)</p>
<ol>
<li>Javascript命名规范以及调用需要注意的方法。</li>
</ol>
<p>1.1 往往定义的共用(移动端[android])函数，都是在index.html中定义的</p>
<p>1.1.1 android对javascript的命名有一定要求</p>
<p>  函数定义，某个页面的某个动作的函数</p>
<p>  (举例：用户信息页面的新建函数&#x3D;&gt; create_user_page() [当然，不是说必须这样命名，  这样命名的好处是，一看就明白是什么意思了]</p>
<pre><code>  不要写成: window.create_user_page() 或者: window.user.create_user_page()这样写的话，android不认识。会报出：ReferenceError  这样的错误而导致页面显示空白)
</code></pre>
<p>1.2 需要get_title() function，获取标题栏文字</p>
<p>　　由于个别标题是动态获取到的，例如：产品名称：西红柿炒蛋，这个是根据传递的产品id请求后端interface得到的。所以，需要等待javascript执行完毕后才可以获取到，不然，会出现问题。(ReferenceError: get_title() is not defined)</p>
<p>1.3 个别的h5页面提交或者保存按钮是在右上角，针对这种情况的处理方法</p>
<p>左上角一般情况下都是 &gt; 返回按钮。所以，新建页面肯定需要，create_function()，编辑页面需要update_function()</p>
<p>  这里需要注意的就是：</p>
<pre><code> 1.3.1 请一定要有返回值
</code></pre>
<p>这样才可以完成android和h5的一个交互的过程，不然，android无法得知是否成功。</p>
<pre><code> 1.3.2 这种函数都需要发送ajax请求，所以在返回值的写法上一定要注意
</code></pre>
<p>赋值需要写在callback中，或者请求方式改为同步请求，这个我相信懂web端都知道。</p>
<p>1.4 android调用h5端javascript一般的写法：</p>
<pre><code>webview.evaluateJavascript(&quot;getPayOrderId()&quot;, new ValueCallback&lt;String&gt;() &#123;

    @Override

    public void onReceiveValue(String value) &#123;

        Log.d(TAG, &quot;getPayOrderId value=&quot; + value);

        if(!value.contains(&quot;null&quot;) &amp;&amp; !value.contains(&quot;NULL&quot;)) &#123;



      //这句用于调试

            Log.d(TAG, &quot;运行到了这里getPayOrderId()&quot; + value);

            orderId =  value;



        &#125;

    &#125;&#125;);
</code></pre>
<p>1.5 往往一个操作对应一个Activity或者一个Fragment，这个一定不要偷懒</p>
<p>2.关于集成微信支付</p>
<p>2.1 添加javabean:</p>
<pre><code>public class WeiXinPayBean implements Serializable &#123;



    private String appId;

    private String partnerid;

    private String prepay_id;

    private String order_id;

    @JSONField(name=&quot;package&quot;)

    private String packageX;

    private String timeStamp;

    private String nonceStr;

    private String return_code;

    private String return_msg;

    private String sign;

    private String err_code_des;



    public String getAppId() &#123;

        return appId;

    &#125;



    public void setAppId(String appId) &#123;

        this.appId = appId;

    &#125;



    public String getPartnerid() &#123;

        return partnerid;

    &#125;



    public void setPartnerid(String partnerid) &#123;

        this.partnerid = partnerid;

    &#125;



    public String getPrepay_id() &#123;

        return prepay_id;

    &#125;



    public void setPrepay_id(String prepay_id) &#123;

        this.prepay_id = prepay_id;

    &#125;



    public void setOrder_id(String order_id) &#123;

        this.order_id = order_id;

    &#125;



    public String getOrder_id() &#123;

        return order_id;

    &#125;



    public String getPackageX() &#123;

        return packageX;

    &#125;



    public void setPackageX(String packageX) &#123;

        this.packageX = packageX;

    &#125;



    public String getTimeStamp() &#123;

        return timeStamp;

    &#125;



    public void setTimeStamp(String timeStamp) &#123;

        this.timeStamp = timeStamp;

    &#125;



    public String getNonceStr() &#123;

        return nonceStr;

    &#125;



    public void setNonceStr(String nonceStr) &#123;

        this.nonceStr = nonceStr;

    &#125;



    public String getReturn_code() &#123;

        return return_code;

    &#125;



    public void setReturn_code(String return_code) &#123;

        this.return_code = return_code;

    &#125;



    public String getReturn_msg() &#123;

        return return_msg;

    &#125;



    public void setReturn_msg(String return_msg) &#123;

        this.return_msg = return_msg;

    &#125;



    public String getSign() &#123;

        return sign;

    &#125;



    public void setSign(String sign) &#123;

        this.sign = sign;

    &#125;



    public String getErr_code_des() &#123;

        return err_code_des;

    &#125;



    public void setErr_code_des(String err_code_des) &#123;

        this.err_code_des = err_code_des;

    &#125;

&#125;
</code></pre>
<p>2.2 添加Activity:</p>
<pre><code>public class WXPayEntryActivity extends Activity implements IWXAPIEventHandler&#123;



   public static final String BASE_URL = &quot;http://h5.touring.com.cn/#!&quot;;

   private static final String PAY_SUCCESS_URL = BASE_URL + &quot;/orders/paysuccess/&quot;;

   private static final String PAY_FAIL_URL = BASE_URL + &quot;/orders/payfail/&quot;;



   private WeiXinPayBean weiXinPayBean;



   public static void show(Activity activity, WeiXinPayBean weiXinPayBean, int requestCode) &#123;

      Intent intent = new Intent(activity, WXPayEntryActivity.class);

      intent.putExtra(&quot;weiXinPayBean&quot;, weiXinPayBean);

      activity.startActivityForResult(intent, requestCode);

   &#125;

   public static void show(Fragment fragment, WeiXinPayBean weiXinPayBean, int requestCode) &#123;

      Intent intent = new Intent(fragment.getActivity(), WXPayEntryActivity.class);

      intent.putExtra(&quot;weiXinPayBean&quot;, weiXinPayBean);

        fragment.startActivityForResult(intent, requestCode);

   &#125;



   private static final String TAG = &quot;WXPayEntryActivity&quot;;



    private IWXAPI api;



    @Override

    public void onCreate(Bundle savedInstanceState) &#123;

        super.onCreate(savedInstanceState);

        setContentView(R.layout.pay_result);



      weiXinPayBean = (WeiXinPayBean) getIntent().getSerializableExtra(&quot;weiXinPayBean&quot;);

        api = WXAPIFactory.createWXAPI(getApplicationContext(), AppCenter.getInstance().WeiXinPayAppId);

      if (weiXinPayBean != null) &#123;

            AppCenter.getInstance().setWeiXinPayAppId(weiXinPayBean.getAppId());

            api = WXAPIFactory.createWXAPI(getApplicationContext(), AppCenter.getInstance().WeiXinPayAppId);

         pay(this, weiXinPayBean);

      &#125; else &#123;

            api = WXAPIFactory.createWXAPI(getApplicationContext(), AppCenter.getInstance().WeiXinPayAppId);

         api.handleIntent(getIntent(), this);

      &#125;

    &#125;



   @Override

   protected void onNewIntent(Intent intent) &#123;

      super.onNewIntent(intent);

      setIntent(intent);

        api.handleIntent(intent, this);

   &#125;



   @Override

   public void onReq(BaseReq req) &#123;

   &#125;



   @Override

   public void onResp(BaseResp resp) &#123;

      Log.d(TAG, &quot;onPayFinish, errCode = &quot; + resp.errCode);



      if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123;

         // errCode: 0 成功， -1 支付失败， -2 用户取消支付



         if (resp.errCode == 0)  &#123;

            setResult(RESULT_OK);

            Toast.makeText(this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show();



            WebViewActivity.show(WXPayEntryActivity.this, PAY_SUCCESS_URL+weiXinPayBean.getOrder_id(), &quot;支付成功&quot;, WebViewActivity.FRAGMENT_ORDER_PAY_SUCCESS, true);

            finish();

         &#125; else &#123;

//                AlertDialog.Builder builder = new AlertDialog.Builder(this);

//                builder.setTitle(&quot;支付结果&quot;);

//                builder.setMessage(String.valueOf(resp.errCode));

//                builder.show();

//                setResult(RESULT_CANCELED);

            WebViewActivity.show(WXPayEntryActivity.this, PAY_FAIL_URL+weiXinPayBean.getOrder_id(), &quot;支付失败&quot;, WebViewActivity.FRAGMENT_ORDER_PAY_FAIL, true);

                finish();

         &#125;

      &#125;

   &#125;





   public void pay(Context context, WeiXinPayBean weiXinPayBean) &#123;

      final IWXAPI msgApi = WXAPIFactory.createWXAPI(context, null);

      // 将该app注册到微信

      msgApi.registerApp(weiXinPayBean.getAppId());



      PayReq request = new PayReq();

      request.appId = weiXinPayBean.getAppId();

      request.partnerId = weiXinPayBean.getPartnerid();

      request.prepayId= weiXinPayBean.getPrepay_id();

      request.packageValue = weiXinPayBean.getPackageX();

      request.nonceStr= weiXinPayBean.getNonceStr();

      request.timeStamp= weiXinPayBean.getTimeStamp();

      request.sign= weiXinPayBean.getSign();

      boolean sendSuccess = msgApi.sendReq(request);

      // 和微信交互可能失败, 失败时直接返回

      if (!sendSuccess) &#123;

         finish();

      &#125;

   &#125;

&#125;
</code></pre>
<p>2.3 修改android拦截部分的代码:</p>
<pre><code>//微信支付  global_function_weixin_pay()  是在h5上完成的微信支付方法

Pattern pattern = Pattern.compile(&quot;run_native_pay&quot;);

Matcher matcher = pattern.matcher(url);

Log.d(TAG, &quot;===== url=================== value=&quot; + url);

if (matcher.find()) &#123;

    Log.d(TAG, &quot;confirm order 微信开始支付&quot;);

    webview.evaluateJavascript(&quot;global_function_weixin_pay()&quot;, new ValueCallback&lt;String&gt;() &#123;

        @Override

        public void onReceiveValue(String value) &#123;

            Log.d(TAG, &quot;global_function_weixin_pay value=&quot; + value);

            if(!value.contains(&quot;null&quot;) &amp;&amp; !value.contains(&quot;NULL&quot;)) &#123;

                String payUrl = translateHtmlStringToLocal(value);

                getPayInfoFromServer(payUrl);

            &#125;

        &#125;&#125;);



    return true;

&#125;
</code></pre>
<p>2.4 微信获取支付信息</p>
<pre><code>com.lidroid.xutils.HttpUtils http = new com.lidroid.xutils.HttpUtils();

http.send(HttpRequest.HttpMethod.GET,

        payUrl,

        null,

        new RequestCallBack&lt;String&gt;() &#123;

            @Override

            public void onSuccess(ResponseInfo&lt;String&gt; responseInfo) &#123;



                if (getActivity() != null) &#123;

                    ((TulingBaseActivity) getActivity()).dismissLoadingDialog();

                &#125;

                if (responseInfo != null &amp;&amp; responseInfo.result != null) &#123;



                    WeiXinPayBean weiXinPayBean = JSON.parseObject(responseInfo.result, WeiXinPayBean.class);

                    Log.d(TAG, &quot;=========onSuccess(ResponseInfo&lt;String&gt; responseInfo)&quot; + weiXinPayBean.getReturn_code().toUpperCase());



                    if (weiXinPayBean.getReturn_code().toUpperCase().equals(&quot;SUCCESS&quot;)) &#123;

                        WXPayEntryActivity.show(ConfirmOrderFragment.this, weiXinPayBean, REQUEST_WEIXIN_PAY);

                        //WXPayEntryActivity.show(OrderPaySuccessFragment.newInstance(pageUrl, &quot;支付成功&quot;, true), weiXinPayBean, REQUEST_WEIXIN_PAY);

                    &#125; else &#123;

                        Toast.makeText(getActivity(), weiXinPayBean.getErr_code_des(), Toast.LENGTH_SHORT).show();

                    &#125;

                &#125; else &#123;

                    if (getActivity() != null) &#123;

                        Toast.makeText(getActivity(), &quot;获取支付信息失败&quot;, Toast.LENGTH_SHORT).show();

                    &#125;

                &#125;

            &#125;



            @Override

            public void onFailure(HttpException e, String s) &#123;

                Log.d(TAG, &quot;=========onFailure(HttpException e, String s)&quot; + s + &quot;============&quot; + e.toString());



                if (getActivity() != null) &#123;

                    ((TulingBaseActivity) getActivity()).dismissLoadingDialog();

                &#125;

                e.printStackTrace();

            &#125;

        &#125;);
</code></pre>
<p>3.关于集成支付宝支付</p>
<p>参照：　</p>
<pre><code>[https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.fBvhyw&amp;treeId=193&amp;articleId=105296&amp;docType=1][https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.fBvhyw&amp;treeId=193&amp;articleId=105296&amp;docType=1]
</code></pre>
<p>3.1 添加javabean:</p>
<pre><code>public class AlipayBean &#123;

    /** 支付宝支付业务：入参app_id */

    private String app_id;

    private Map&lt;String, String&gt; biz_content;

    private String bit_content_json;

    private String method;

    private String charset;

    private String sign_type;

    /** 商户私钥，pkcs8格式 */

    private String sign;



    private String timestamp;

    private String version;

    private String notify_url;



    public String getApp_id() &#123;

        return app_id;

    &#125;



    public void setApp_id(String app_id) &#123;

        this.app_id = app_id;

    &#125;



    public Map&lt;String, String&gt; getBiz_content() &#123;

        return biz_content;

    &#125;



    public void setBiz_content(Map&lt;String, String&gt; biz_content) &#123;

        this.biz_content = biz_content;

    &#125;



    public String getBit_content_json() &#123;

        return bit_content_json;

    &#125;



    public void setBit_content_json(String bit_content_json) &#123;

        this.bit_content_json = bit_content_json;

    &#125;



    public String getMethod() &#123;

        return method;

    &#125;



    public void setMethod(String method) &#123;

        this.method = method;

    &#125;



    public String getCharset() &#123;

        return charset;

    &#125;



    public void setCharset(String charset) &#123;

        this.charset = charset;

    &#125;



    public String getSign_type() &#123;

        return sign_type;

    &#125;



    public void setSign_type(String sign_type) &#123;

        this.sign_type = sign_type;

    &#125;



    public String getSign() &#123;

        return sign;

    &#125;



    public void setSign(String sign) &#123;

        this.sign = sign;

    &#125;



    public String getTimestamp() &#123;

        return timestamp;

    &#125;



    public void setTimestamp(String timestamp) &#123;

        this.timestamp = timestamp;

    &#125;



    public String getVersion() &#123;

        return version;

    &#125;



    public void setVersion(String version) &#123;

        this.version = version;

    &#125;



    public String getNotify_url() &#123;

        return notify_url;

    &#125;



    public void setNotify_url(String notify_url) &#123;

        this.notify_url = notify_url;

    &#125;
&#125;
</code></pre>
<p>3.2 添加util:</p>
<pre><code>public class OrderInfoUtil2_0 &#123;



   /**

    * 构造授权参数列表

    *

    * @param pid

    * @param app_id

    * @param target_id

    * @return

    */

   public static Map&lt;String, String&gt; buildAuthInfoMap(String pid, String app_id, String target_id) &#123;

      Map&lt;String, String&gt; keyValues = new HashMap&lt;String, String&gt;();



      // 商户签约拿到的app_id，如：2013081700024223

      keyValues.put(&quot;app_id&quot;, app_id);



      // 商户签约拿到的pid，如：2088102123816631

      keyValues.put(&quot;pid&quot;, pid);



      // 服务接口名称， 固定值

      keyValues.put(&quot;apiname&quot;, &quot;com.alipay.account.auth&quot;);



      // 商户类型标识， 固定值

      keyValues.put(&quot;app_name&quot;, &quot;mc&quot;);



      // 业务类型， 固定值

      keyValues.put(&quot;biz_type&quot;, &quot;openservice&quot;);



      // 产品码， 固定值

      keyValues.put(&quot;product_id&quot;, &quot;APP_FAST_LOGIN&quot;);



      // 授权范围， 固定值

      keyValues.put(&quot;scope&quot;, &quot;kuaijie&quot;);



      // 商户唯一标识，如：kkkkk091125

      keyValues.put(&quot;target_id&quot;, target_id);



      // 授权类型， 固定值

      keyValues.put(&quot;auth_type&quot;, &quot;AUTHACCOUNT&quot;);



      // 签名类型

      keyValues.put(&quot;sign_type&quot;, &quot;RSA&quot;);



      return keyValues;

   &#125;



   /**

    * 构造支付订单参数列表

    */

   public static Map&lt;String, String&gt; buildOrderParamMap(AlipayBean alipayBean) &#123;

      Map&lt;String, String&gt; keyValues = new HashMap&lt;String, String&gt;();



      keyValues.put(&quot;app_id&quot;, alipayBean.getApp_id());



      Log.d(&quot;OrderInfoUtil2_0&quot;, alipayBean.getBit_content_json());



      keyValues.put(&quot;biz_content&quot;, alipayBean.getBit_content_json());



      keyValues.put(&quot;charset&quot;, alipayBean.getCharset());



      keyValues.put(&quot;method&quot;, alipayBean.getMethod());



      keyValues.put(&quot;sign_type&quot;, alipayBean.getSign_type());



      Log.d(&quot;OrderInfoUtil2_0&quot;, &quot;===========curDate=======&quot; + alipayBean.getTimestamp());

      keyValues.put(&quot;timestamp&quot;, alipayBean.getTimestamp());

//

      keyValues.put(&quot;version&quot;, alipayBean.getVersion());



//    keyValues.put(&quot;timestamp&quot;, &quot;2016-07-29 16:55:53&quot;);



//    keyValues.put(&quot;version&quot;, &quot;1.0&quot;);



      Log.d(&quot;OrderInfoUtil2_0&quot;, &quot;notify_url===========&quot; + alipayBean.getNotify_url());



      keyValues.put(&quot;notify_url&quot;, alipayBean.getNotify_url());



      return keyValues;

   &#125;



   /**

    * 构造支付订单参数信息

    *

    * @param map

    * 支付订单参数

    * @return

    */

   public static String buildOrderParam(Map&lt;String, String&gt; map) &#123;

      List&lt;String&gt; keys = new ArrayList&lt;String&gt;(map.keySet());

      //这句是后来添加的

      Collections.sort(keys);



      StringBuilder sb = new StringBuilder();

      for (int i = 0; i &lt; keys.size() - 1; i++) &#123;

         String key = keys.get(i);

         String value = map.get(key);

         sb.append(buildKeyValue(key, value, true));

         sb.append(&quot;&amp;&quot;);

      &#125;



      String tailKey = keys.get(keys.size() - 1);

      String tailValue = map.get(tailKey);

      sb.append(buildKeyValue(tailKey, tailValue, true));



      return sb.toString();

   &#125;



   /**

    * 拼接键值对

    *

    * @param key

    * @param value

    * @param isEncode

    * @return

    */

   private static String buildKeyValue(String key, String value, boolean isEncode) &#123;

      StringBuilder sb = new StringBuilder();

      sb.append(key);

      sb.append(&quot;=&quot;);

      if (isEncode) &#123;

         try &#123;

            sb.append(URLEncoder.encode(value, &quot;UTF-8&quot;));

         &#125; catch (UnsupportedEncodingException e) &#123;

            sb.append(value);

         &#125;

      &#125; else &#123;

         sb.append(value);

      &#125;

      return sb.toString();

   &#125;



   /**

    * 对支付参数信息进行签名

    *

    * @param map

    * 待签名授权信息

    *

    * @return

    */

   public static String getSign(Map&lt;String, String&gt; map, String rsaKey) &#123;

      List&lt;String&gt; keys = new ArrayList&lt;String&gt;(map.keySet());

      // key排序

      Collections.sort(keys);



      Log.d(&quot;OrderInfoUtil2_0&quot;, &quot;===========================sort keys.toString()============&quot; + keys.toString());



      StringBuilder authInfo = new StringBuilder();

      for (int i = 0; i &lt; keys.size() - 1; i++) &#123;

         String key = keys.get(i);

         String value = map.get(key);

         authInfo.append(buildKeyValue(key, value, false));

         authInfo.append(&quot;&amp;&quot;);

      &#125;



      String tailKey = keys.get(keys.size() - 1);

      String tailValue = map.get(tailKey);

      authInfo.append(buildKeyValue(tailKey, tailValue, false));



      String oriSign = SignUtils.sign(authInfo.toString(), rsaKey);

      String encodedSign = &quot;&quot;;



      try &#123;

         encodedSign = URLEncoder.encode(oriSign, &quot;UTF-8&quot;);

      &#125; catch (UnsupportedEncodingException e) &#123;

         e.printStackTrace();

      &#125;

      return &quot;sign=&quot; + encodedSign;

   &#125;



   /**

    * 使用内部生成的订单号，不使用该方法生成了

    * 要求外部订单号必须唯一。

    * @return

    */

   private static String getOutTradeNo() &#123;

      SimpleDateFormat format = new SimpleDateFormat(&quot;MMddHHmmss&quot;, Locale.getDefault());

      Date date = new Date();

      String key = format.format(date);



      Random r = new Random();

      key = key + r.nextInt();

      key = key.substring(0, 15);

      return key;

   &#125;
&#125;
</code></pre>
<p>3.3 添加签名util:</p>
<pre><code>public class SignUtils &#123;



    private static final String ALGORITHM = &quot;RSA&quot;;



    private static final String SIGN_ALGORITHMS = &quot;SHA1WithRSA&quot;;



    private static final String DEFAULT_CHARSET = &quot;UTF-8&quot;;



    public static String sign(String content, String privateKey) &#123;

        try &#123;

            PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(

                    Base64.decode(privateKey));

            KeyFactory keyf = KeyFactory.getInstance(ALGORITHM);

            PrivateKey priKey = keyf.generatePrivate(priPKCS8);



            java.security.Signature signature = java.security.Signature

                    .getInstance(SIGN_ALGORITHMS);



            signature.initSign(priKey);

            signature.update(content.getBytes(DEFAULT_CHARSET));



            byte[] signed = signature.sign();



            return Base64.encode(signed);

        &#125; catch (Exception e) &#123;

            e.printStackTrace();

        &#125;



        return null;

    &#125;



&#125;
</code></pre>
<p>3.4 获取支付信息，打开支付宝:</p>
<pre><code>        Map&lt;String, String&gt; params = OrderInfoUtil2_0.buildOrderParamMap(alipayBean);

        String orderParam = OrderInfoUtil2_0.buildOrderParam(params);

        String sign = OrderInfoUtil2_0.getSign(params, alipayBean.getSign());

        final String payInfo = orderParam + &quot;&amp;&quot; + sign;



        /**

         * 完整的符合支付宝参数规范的订单信息

         */

        Log.d(TAG, &quot;==========payInfo=============&quot; + payInfo);

        Runnable payRunnable = new Runnable() &#123;

            @Override

            public void run() &#123;

                PayTask payTask = new PayTask(getActivity());

                Map&lt;String, String&gt; result = payTask.payV2(payInfo, true);

                Log.d(TAG, &quot;=================result===&quot; + result.toString());



                Message msg = new Message();

                msg.what = SDK_PAY_FLAG;

                msg.obj = result;

                handler.sendMessage(msg);

            &#125;

        &#125;;



        Thread payThread = new Thread(payRunnable);

        payThread.start();
</code></pre>
<p>3.5 处理返回结果</p>
<p>&#x2F;&#x2F; 判断resultStatus 为“9000”则代表支付成功，具体状态码代表含义可参考接口文档</p>
<p>if (TextUtils.equals(resultStatus, “9000”)) {</p>
<pre><code>Toast.makeText(getActivity(), &quot;支付成功&quot;, Toast.LENGTH_SHORT).show();
</code></pre>
<p>} else {</p>
<pre><code>// 判断resultStatus 为非&quot;9000&quot;则代表可能支付失败

// &quot;8000&quot;代表支付结果因为支付渠道原因或者系统原因还在等待支付结果确认，最终交易是否成功以服务端异步通知为准（小概率状态）

if (TextUtils.equals(resultStatus, &quot;8000&quot;)) &#123;

    Toast.makeText(getActivity(), &quot;支付结果确认中&quot;, Toast.LENGTH_SHORT).show();

&#125; else &#123;

    // 其他值就可以判断为支付失败，包括用户主动取消支付，或者系统返回的错误

    Toast.makeText(getActivity(), &quot;支付失败&quot;, Toast.LENGTH_SHORT).show();

&#125;
</code></pre>
<p>}</p>
<p>3.6 关于支付宝后端接口的实现</p>
<p>3.6.1 首先将签名参数等信息需要放在接口端(即服务器端)</p>
<p>参照:</p>
<p><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.JMiXfS&treeId=193&articleId=105465&docType=1">https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.JMiXfS&treeId=193&articleId=105465&docType=1</a></p>
<pre><code>def alipay

    @order = ShoppingOrder.find_by_id(params[:order_id])

    biz_content = &#123;

        timeout_express: &#39;30m&#39;,

        seller_id: &#39;&#39;,

        product_code: &quot;QUICK_MSECURITY_PAY&quot;,

        total_amount: @order.buy_couts * @order.shopping_product.price.to_f,

        subject: &quot;#&#123;@order.shopping_product.name&#125; x #&#123;@order.buy_couts&#125;&quot;,

        body: &quot;#&#123;params[:order_id]&#125;&quot;,

        out_trade_no: @order.order_number,

      &#125;



    result = &#123;

      :app_id      =&gt; YOURAPPID,

      :method      =&gt; &#39;alipay.trade.app.pay&#39;,

      :charset     =&gt; &#39;utf-8&#39;,

      :sign_type   =&gt; &#39;RSA&#39;,

      :sign        =&gt; YOURSIGN(商户私钥，pkcs8格式),

      :timestamp   =&gt; Time.now.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;),

      :version     =&gt; &#39;1.0&#39;,

      :notify_url  =&gt; YOURNOTIFYURL,

      :bit_content =&gt; biz_content,

      :bit_content_json =&gt; biz_content.to_json

    &#125;

    render json: result

End
</code></pre>
<p>关于YOURSIGN, 即商户私钥的说明, 参照:</p>
<pre><code>https://doc.open.alipay.com/doc2/detail.htm?treeId=193&amp;articleId=105310&amp;docType=1#s0
</code></pre>
<p>使用OpenSSL工具生成的.</p>
<p>3.6.2 实现相应的回调地址action(即上面提到的notify_url)</p>
<pre><code>def alipay_notify

    notify_params = params.except(*request.path_parameters.keys)

    Rails.logger.info &quot;支付宝回调结果：&quot;

    Rails.logger.info notify_params

    verify_result = Alipay::Notify.verify?(notify_params)

    Rails.logger.info verify_result

    Rails.logger.info &quot;==  order_id ========== #&#123;notify_params[&#39;body&#39;].to_i&#125;----&quot;



        #判断返回结果

    if true

      @order = ShoppingOrder.find(notify_params[&#39;body&#39;].to_i)

      begin

        unless @order.blank?

          Rails.logger.info &quot;==  order is not blank !!!!!----&quot;

          time = Time.now.to_datetime

          #修改相应的订单状态

          @order.update_attributes(:payment_status =&gt; 1, :order_status =&gt; 1, :collect =&gt; notify_params[&#39;total_amount&#39;], :payed_at =&gt; time)

        else

          Rails.logger.info &quot;==  order is blank !!!!!----&quot;

          Rails.logger.info @order.errors

        end

              render :json =&gt; &#123; return_code: &quot;success&quot; &#125;

      rescue &#39;&#39;

        Rails.logger.error &#39;shopping_order pay error&#39;

              render :json =&gt; &#123; return_code: &quot;fail&quot;, return_msg: &quot;&quot; &#125;

      end

    else

            render :json =&gt; &#123; return_code: &quot;fail&quot;, return_msg: &quot;&quot; &#125;

    end

end
</code></pre>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>[Capistrano]Capistrano: 自动化部署的利器</title>
    <url>/2022/07/05/Capistrano%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<pre><code>            capistrano是个好用的自动化部署工具, 能够快速自动的将自己的代码部署到正式服务器上面。

            安装方式：

            进入到项目目录下面,并增加下面内容到 Gemfile 中：

            group :development gem &#39;capistrano&#39;, &#39;2.12.0&#39; gem &#39;capistrano-rbenv&#39;, &#39;1.0.1&#39; end

            安装添加的gem

            $ bundle install

            再运行下面的命令：

            $ capify .

            会生成两个关键性的文件： Capfile , config/deploy.rb

            编辑后者config/deploy.rb

            加上自己的capistrano配置信息

            启动deploy中的setup任务,创建一些必要文件夹

            $ cap deploy:setup

            编辑远程的数据库,thin等配置文件

             ../shared/config/database.yml
                ../shared/config/database.yml

            开始部署

            $ cap deploy.

            下面是一个完整的deploy.rb文件：

            https://github.com/beijing-rubyist/bjrubyist/blob/master/config/deploy.rb

            使用命令行

            下面是一个例子，在命令行中显示 User name: , 等用户输入完，按回车之后， 把输入的值赋给 user 变量。

            set(:user) &#123; Capistrano::CLI.ui.ask(&quot;User name: &quot;) &#125;

            使用帮助：

            $ cap --help

            使用logger，特别是在其他语言调用CAP时，非常有用（例如被fabric 调用）:

            $ cap setup --logger STDOUT

            如何使用变量?

            要记得: 使用@. . 例如，我们要设置 &quot;deploy_type&quot; 这个变量：

            $ cap say_hi --set-before deploy_type=staging

            然后在 config/deploy.rb 中这样使用：

            DEFAULT_TYPE = &quot;stable&quot; # deploy_type 仅仅在 begin 这个区域中生效, 在rescue, ensure中都不行。  begin deploy_type

                puts &quot;deploy_type was set successfully&quot; @deploy_type = deploy_type rescue Exception =&gt; e

                puts &quot;deploy_type not set, use default: #&#123;DEFAULT_TYPE&#125;&quot; deploy_type = DEFAULT_TYPE @deploy_type = deploy_type end task :say_hi do puts &quot;hihihi, var_deploy_type: #&#123;@deploy_type&#125;&quot; end

            输出：

            deploy_type was set successfully

            ============= DEPLOY_PATH: /rails_apps/babble_portal/cutting_edge

            * executing `say_hi&#39;

            hihihi, var_deploy_type: 444

            最后，使用copy方式：

            # 脚本中

            set :scm, :none

            set :repository, &quot;.&quot;

            set :deploy_via, :copy

            capistrano的输出详解



            TODO 各种屏幕截图。 建立文件夹， 打包，压缩，上传，解压缩， rake db.. assets等等

            为什么要用capistrano



            流行的工具都是有道理的（ best practices are best in most cases)

            版本控制：SVN =&gt; GIT( scm : from SVN to GIT)

            部署方式：人肉部署 =&gt; Capistrano

            原来项目中用到的是SVN， 就一个分支，也不打tag。感觉用起来没啥。 ( there&#39;s not so much trouble when the project is going under SVN and manual deployment)

            现在服务器的配置被运维同学限制了，无法连到SCM服务器 (同时无法连接到外网，无法连接到很多内部网络，比如LDAP，RADIUS等等）。肿么办???? (but one day, the server was limited its access to the internet, git repo and local LDAP , Radius service... what shall we do? )

            如果用SVN的话，就得用SCP的方式，打包过去，然后修修改改，每次都要人肉来做，还出错。(if using SVN, we have to copy the entire code folder to the target server, easy to make mistake and really painful for me )

            现在换成了GIT，不用capistrano的话，直接在本地把 git-patch 上传过去，然后 git am 就好。(now since we have migrated the SVN to GIT repo, it&#39;s very easy to achieve the same goal using &#39;git-patch&#39; and &#39;git am&#39; )

            用了capistrano的话，用 deploy_via :scp 的 方式，我每次部署一行命令，自动搞定了。 ( and in capistrano, we just need to use &#39;deploy_via scp&#39; to do the deployment job )

            所以，老式的办法，在某些新问题出现的时刻，不是那么得心应手。业界流行的“最佳实践”，在大部分情况下，还是“最佳实践”的。 ^_^ ( the conclusion is: best practices are always best in most cases. )

            —— 学习是王道！ ( keep STUDYING everyday! )

            capistrano的原理



            裸代码: 没有数据库的配置文件, 没有服务器相关的配置文件, 也没有压缩各种css/js , 一般都是从git上直接clone下来的代码。

            传统的部署步骤:



            ssh 登陆到服务器

            git pull

            restart command（重新启动）

            坏处是:

            无法回滚,

            每次都人肉, 特别麻烦.

            虽然上面3个步骤看似很少, 但是需要一直盯着(比如, ssh 需要10秒, git pull 需要20秒, restart 也需要人肉输入, 这些都是时间上的损耗, 而且人肉做重复性的事情, 无趣, 容易出错。

            合理的部署是:



            编写好一个配置文件之后, 运行代码: $ cap deploy (一个命令) , 之后的所有事情,都不用人参与了。

            结构:



            有三个角色:部署人员的机器,目标服务器,代码服务器(GIT)

            TODO: 没xuan的图片

            ( 见譞的本本上的图 )

            每次部署, 都要做的事情:



            SSH 到目标服务器

            把最新的代码,上传到目标服务器上。这时候的代码是裸代码，不能立刻部署, 因为很多配置文件都没有。

            我们不能把配置文件也放到github里面跟踪, 比如: config/database.yml , 每个人或服务器的数据库的 mysql 密码都不一样。

            以及其他的内容(上传文件夹)

            项目的回滚



            回滚的方式有几种:

            code roll back

            git checkout ... 这样不好,很多时候我们无法保证代码是没有被修改的。 被修改之后, checkout操作会涉及到代码合并的情况, 在某些 紧急 BUG 出现时, 会特别明显.

            使用capistrano,将上一次的release回滚,每一个release都用一个文件夹(里面包含了完整的项目代码, 包括裸代码, 和 各种配置文件)。

            目录结构

            20150310010954, 20150319015536 这种时间戳命名的文件夹，代码某一个时间段部署的版本。

            有一个特殊的softlink(软链接),current。

            web服务器的nginx配置,thin配置可以指向这个softlink,这样就不需要每次都改nginx，thin 的配置文件了, 只需要把current这个softlink,重新指向不同的 release 文件夹就可以了。

            shared文件夹中所保存的内容, 以及部分目录结构, 是由 config/deploy.rb 这个配置文件决定的

            capistrano部署web应用的文件结构是:

            /opt/rails_app:

                    current -&gt; /opt/app/happystock_web/releases/20150518030114/

                    releases/

                            20150310010954

                            20150319015536

                            20150518030114

                    shared/

                            assets

                            config

                            files

                            log

                            pids

                            public

                            system

            capistrano执行的内容



            准备启动服务器:

            安装各种新增的rubygem

            做必要的数据库迁移

            配置各种文件

            修改上传文件夹的softlink

            其他,每次使用裸代码做部署的时候,都要人肉做的事情. (修改保存日志的路径, 修改 rails server的配置, )

            编译,压缩 js/ css

            重启 服务器( $ nginx -s reload, $ kill -9 xxx , $ thin start -C config/thin.yml)

            使用方式



            首次运行前的准备工作



            自动生成文件夹：

            $ cap deploy:setup # 建立需要的各种文件夹

            注意： 这里务必记得， 盯紧控制台的输出， 看到它执行完 mkdir -p 之后， 赶紧按ctrl + c 暂停。否则它会默认在远程服务器上安装各种ruby 第三方包，安装各种linux 依赖包。一不小心就会把服务器环境搞砸了。

            为 shared 目录下，增加各种配置文件，它们只需要被配置一遍。例如：

            config/thin.yml # 服务器的配置 config/database.yml # 数据库的配置 config/log4r.yml # 日志文件的配置 config/settings.yml # 系统的配置

            配置好ruby环境， mysql, thin, nginx 等

            $ bundle exec cap deploy

            再次部署（更新版本）



            只需要运行$ cap deploy即可。

            常见问题



            无法部署capistrano? Net::SSH::AuthenticationFailed: Authentication failed



            对于capistrano 2.12.0,显式指定Gemfile中net-ssh 的版本，例如：

            gem &#39;net-ssh&#39;, &#39;2.7.0&#39;
</code></pre>
]]></content>
      <categories>
        <category>Capistrano</category>
      </categories>
  </entry>
  <entry>
    <title>[Git]Git忽略规则及.gitignore规则不生效的解决办法</title>
    <url>/2016/10/28/Git%E5%BF%BD%E7%95%A5%E8%A7%84%E5%88%99%E5%8F%8Agitignore%E8%A7%84%E5%88%99%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<pre><code>git rm -r --cached .

git add .

git commit -m &#39;update .gitignore&#39;
</code></pre>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>[MySql]中添加用户,新建数据库,用户授权,删除用户,修改密码</title>
    <url>/2022/07/05/MySQL%E6%93%8D%E4%BD%9C%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<p>MySql中添加用户,新建数据库,用户授权,删除用户,修改密码(注意每行后边都跟个;表示一个命令语句结束):</p>
<p>1.新建用户</p>
<p>登录MYSQL：</p>
<p>@&gt;mysql -u root -p</p>
<p>@&gt;密码</p>
<p>创建用户：</p>
<p>mysql&gt; insert into mysql.user(Host,User,Password) values(“localhost”,”test”,password(“1234”));</p>
<p>这样就创建了一个名为：test 密码为：1234 的用户。</p>
<p>注意：此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录。如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。</p>
<p>然后登录一下：</p>
<p>mysql&gt;exit;</p>
<p>@&gt;mysql -u test -p</p>
<p>@&gt;输入密码</p>
<p>mysql&gt;登录成功</p>
<p>2.为用户授权</p>
<p>授权格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by “密码”;</p>
<p>登录MYSQL（有ROOT权限），这里以ROOT身份登录：</p>
<p>@&gt;mysql -u root -p</p>
<p>@&gt;密码</p>
<p>首先为用户创建一个数据库(testDB)：</p>
<p>mysql&gt;create database testDB;</p>
<p>授权test用户拥有testDB数据库的所有权限（某个数据库的所有权限）：</p>
<p>mysql&gt;grant all privileges on testDB.* to test@localhost identified by ‘1234’;</p>
<p>mysql&gt;flush privileges;&#x2F;&#x2F;刷新系统权限表</p>
<p>格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by “密码”;</p>
<p>如果想指定部分权限给一用户，可以这样来写:</p>
<p>mysql&gt;grant select,update on testDB.* to test@localhost identified by ‘1234’;</p>
<p>mysql&gt;flush privileges; &#x2F;&#x2F;刷新系统权限表</p>
<p>授权test用户拥有所有数据库的某些权限： 　</p>
<p>mysql&gt;grant select,delete,update,create,drop on <em>.</em> to test@”%” identified by “1234”;</p>
<pre><code> //test用户对所有数据库都有select,delete,update,create,drop 权限。
</code></pre>
<p>&#x2F;&#x2F;@”%” 表示对所有非本地主机授权，不包括localhost。（localhost地址设为127.0.0.1，如果设为真实的本地地址，不知道是否可以，没有验证。）</p>
<p>&#x2F;&#x2F;对localhost授权：加上一句grant all privileges on testDB.* to test@localhost identified by ‘1234’;即可。</p>
<p>3.删除用户</p>
<p> @&gt;mysql -u root -p</p>
<p> @&gt;密码</p>
<p> mysql&gt;Delete FROM user Where User&#x3D;’test’ and Host&#x3D;’localhost’;</p>
<p> mysql&gt;flush privileges;</p>
<p> mysql&gt;drop database testDB; &#x2F;&#x2F;删除用户的数据库</p>
<p>删除账户及权限：&gt;drop user 用户名@’%’;</p>
<blockquote>
<p>drop user 用户名@ localhost;</p>
</blockquote>
<p>4.修改指定用户密码</p>
<p>  @&gt;mysql -u root -p</p>
<p>  @&gt;密码</p>
<p>  mysql&gt;update mysql.user set password&#x3D;password(‘新密码’) where User&#x3D;”test” and Host&#x3D;”localhost”;</p>
<p>  mysql&gt;flush privileges;</p>
<p>5.列出所有数据库</p>
<p>mysql&gt;show database;</p>
<p>6.切换数据库</p>
<p>mysql&gt;use ‘数据库名’;</p>
<p>7.列出所有表</p>
<p>mysql&gt;show tables;</p>
<p>8.显示数据表结构</p>
<p>mysql&gt;describe 表名;</p>
<p>9.删除数据库和数据表</p>
<p>mysql&gt;drop database 数据库名;</p>
<p>mysql&gt;drop table 数据表名;</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
  </entry>
  <entry>
    <title>[RubyOnRails]Rails 布局和视图渲染</title>
    <url>/2022/07/05/Rails%20%E5%B8%83%E5%B1%80%E5%92%8C%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>什么都不渲染</p>
<p>或许 render 方法最简单的用法是什么也不渲染：</p>
<p>render nothing: true</p>
<p>渲染文本</p>
<p>调用 render 方法时指定 :plain 选项，可以把没有标记语言的纯文本发给浏览器：</p>
<p>render plain: “OK”</p>
<p>渲染普通的 JavaScript</p>
<p>Rails 能渲染普通的 JavaScript：</p>
<p>render js: “alert(‘Hello Rails’);”</p>
<p>layout 选项</p>
<p>render 方法的大多数选项渲染得到的结果都会作为当前布局的一部分显示。后文会详细介绍布局。</p>
<p>:layout 选项告知 Rails，在当前动作中使用指定的文件作为布局：</p>
<p>render layout: “special_layout”</p>
<p>也可以告知 Rails 不使用布局：</p>
<p>render layout: false</p>
<p> 运行时选择布局</p>
<p>可以使用一个 Symbol，在处理请求时选择布局：</p>
<pre><code>class ProductsController &lt; ApplicationController

    layout :products_layout

    def show
        @product = Product.find(params[:id])
    end

    private
    def products_layout
        @current_user.special? ? &quot;special&quot; : &quot;products&quot;
    end

end
</code></pre>
<p>如果当前用户是特殊用户，会使用一个特殊布局渲染产品视图。</p>
<p>还可使用行间方法，例如 Proc，决定使用哪个布局。如果使用 Proc，其代码块可以访问 controller 实例，这样就能根据当前请求决定使用哪个布局：</p>
<pre><code>class ProductsController &lt; ApplicationController
 layout Proc.new &#123; |controller| controller.request.xhr? ? &quot;popup&quot; : &quot;application&quot; &#125;
end
</code></pre>
<p>2.2.14.3 条件布局</p>
<p>在控制器中指定布局时可以使用 :only 和 :except 选项。这两个选项的值可以是一个方法名或者一个方法名数组，这些方法都是控制器中的动作：</p>
<pre><code>class ProductsController &lt; ApplicationController
 layout &quot;product&quot;, except: [:index, :rss]
end
</code></pre>
<p>这么声明后，除了 rss 和 index 动作之外，其他动作都使用 product 布局渲染视图。</p>
<p>2.2.14.4 布局继承</p>
<p>布局声明按层级顺序向下顺延，专用布局比通用布局优先级高。例如：</p>
<p>  ● application_controller.rb</p>
<pre><code>class ApplicationController &lt; ActionController::Base
 layout &quot;main&quot;
end
</code></pre>
<p>  ● posts_controller.rb</p>
<pre><code>class PostsController &lt; ApplicationController
end
</code></pre>
<p>  ● special_posts_controller.rb</p>
<pre><code>class SpecialPostsController &lt; PostsController
 layout &quot;special&quot;
end
</code></pre>
<p>  ● old_posts_controller.rb</p>
<pre><code>class OldPostsController &lt; SpecialPostsController
    layout false

    def show
        @post = Post.find(params[:id])
    end

    def index
        @old_posts = Post.older
        render layout: &quot;old&quot;
    end
    # ...
end
</code></pre>
<p>在这个程序中：</p>
<p>  ● 一般情况下，视图使用 main 布局渲染；</p>
<p>  ● PostsController#index 使用 main 布局；</p>
<p>  ● SpecialPostsController#index 使用 special 布局；</p>
<p>  ● OldPostsController#show 不用布局；</p>
<p>  ● OldPostsController#index 使用 old 布局；</p>
<p>2.2.15 避免双重渲染错误</p>
<p>大多数 Rails 开发者迟早都会看到一个错误消息：Can only render or redirect once per action（动作只能渲染或重定向一次）。这个提示很烦人，也很容易修正。出现这个错误的原因是，没有理解 render 的工作原理。</p>
<p>例如，下面的代码会导致这个错误：</p>
<pre><code>def show
 @book = Book.find(params[:id])
 if @book.special?
    render action: &quot;special_show&quot;
 end
 render action: &quot;regular_show&quot;
end
</code></pre>
<p>如果 @book.special? 的结果是 true，Rails 开始渲染，把 @book 变量导入 special_show 视图中。但是，show 动作并不会就此停止运行，当 Rails 运行到动作的末尾时，会渲染regular_show 视图，导致错误出现。解决的办法很简单，确保在一次代码运行路线中只调用一次 render 或 redirect_to 方法。有一个语句可以提供帮助，那就是 and return。下面的代码对上述代码做了修改：</p>
<pre><code>def show
    @book = Book.find(params[:id])
    if @book.special?
        render action: &quot;special_show&quot; and return
    end
    render action: &quot;regular_show&quot;
end
</code></pre>
<p>千万别用 &amp;&amp; return 代替 and return，因为 Ruby 语言操作符优先级的关系，&amp;&amp; return 根本不起作用。</p>
<p>注意，ActionController 能检测到是否显式调用了 render 方法，所以下面这段代码不会出错：</p>
<pre><code>def show
 @book = Book.find(params[:id])
 if @book.special?
 render action: &quot;special_show&quot;
 end
end
</code></pre>
<p>如果 @book.special? 的结果是 true，会渲染 special_show 视图，否则就渲染默认的 show 模板。</p>
<p>2.3 使用 redirect_to 方法</p>
<p>响应 HTTP 请求的另一种方法是使用 redirect_to。如前所述，render 告诉 Rails 构建响应时使用哪个视图（以及其他静态资源）。redirect_to 做的事情则完全不同：告诉浏览器向另一个地址发起新请求。例如，在程序中的任何地方使用下面的代码都可以重定向到 photos 控制器的 index 动作：</p>
<p>redirect_to photos_url</p>
<p>redirect_to 方法的参数与 link_to 和 url_for 一样。有个特殊的重定向，返回到前一个页面：</p>
<p>redirect_to :back</p>
<p>2.3.1 设置不同的重定向状态码</p>
<p>调用 redirect_to 方法时，Rails 会把 HTTP 状态码设为 302，即临时重定向。如果想使用其他的状态码，例如 301（永久重定向），可以设置 :status 选项：</p>
<p>redirect_to photos_path, status: 301</p>
<p>和 render 方法的 :status 选项一样，redirect_to 方法的 :status 选项同样可使用数字状态码或符号。</p>
<p>2.3.2 render 和 redirect_to 的区别</p>
<p>有些经验不足的开发者会认为 redirect_to 方法是一种 goto 命令，把代码从一处转到别处。这么理解是不对的。执行到 redirect_to 方法时，代码会停止运行，等待浏览器发起新请求。你需要告诉浏览器下一个请求是什么，并返回 302 状态码。</p>
<p>下面通过实例说明。</p>
<pre><code>def index
 @books = Book.all
end

def show
 @book = Book.find_by(id: params[:id])
 if @book.nil?
 render action: &quot;index&quot;
 end
end
</code></pre>
<p>在这段代码中，如果 @book 变量的值为 nil 很可能会出问题。记住，render :action 不会执行目标动作中的任何代码，因此不会创建 index 视图所需的 @books 变量。修正方法之一是不渲染，使用重定向：</p>
<pre><code>def index
 @books = Book.all
end

def show
 @book = Book.find_by(id: params[:id])
 if @book.nil?
 redirect_to action: :index
 end
end
</code></pre>
<p>这样修改之后，浏览器会向 index 动作发起新请求，执行 index 方法中的代码，一切都能正常运行。</p>
<p>这种方法有个缺点，增加了浏览器的工作量。浏览器通过 &#x2F;books&#x2F;1 向 show 动作发起请求，控制器做了查询，但没有找到对应的图书，所以返回 302 重定向响应，告诉浏览器访问&#x2F;books&#x2F;。浏览器收到指令后，向控制器的 index 动作发起新请求，控制器从数据库中取出所有图书，渲染 index 模板，将其返回浏览器，在屏幕上显示所有图书。</p>
<p>在小型程序中，额外增加的时间不是个问题。如果响应时间很重要，这个问题就值得关注了。下面举个虚拟的例子演示如何解决这个问题：</p>
<pre><code>def index
 @books = Book.all
end

def show
    @book = Book.find_by(id: params[:id])
    if @book.nil?
        @books = Book.all
        flash.now[:alert] = &quot;Your book was not found&quot;
        render &quot;index&quot;
    end
end
</code></pre>
<p>在这段代码中，如果指定 ID 的图书不存在，会从模型中取出所有图书，赋值给 @books 实例变量，然后直接渲染 index.html.erb 模板，并显示一个 Flash 消息，告知用户出了什么问题。</p>
<p>2.4 使用 head 构建只返回报头的响应</p>
<p>head 方法可以只把报头发送给浏览器。还可使用意图更明确的 render :nothing 达到同样的目的。head 方法的参数是 HTTP 状态码的符号形式（参见前文表格），选项是一个 Hash，指定报头名和对应的值。例如，可以只返回报错的报头：</p>
<p>head :bad_request</p>
<p>生成的报头如下：</p>
<pre><code>HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
</code></pre>
<p>或者使用其他 HTTP 报头提供其他信息：</p>
<p>head :created, location: photo_path(@photo)</p>
<p>生成的报头如下：</p>
<pre><code>HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
</code></pre>
<p>3 布局结构</p>
<p>Rails 渲染响应的视图时，会把视图和当前模板结合起来。查找当前模板的方法前文已经介绍过。在布局中可以使用三种工具把各部分合在一起组成完整的响应：</p>
<p>  ● 静态资源标签</p>
<p>  ● yield 和 content_for</p>
<p>  ● 局部视图</p>
<p>3.1 静态资源标签帮助方法</p>
<p>静态资源帮助方法用来生成链接到 Feed、JavaScript、样式表、图片、视频和音频的 HTML 代码。Rails 提供了六个静态资源标签帮助方法：</p>
<p>  ● auto_discovery_link_tag</p>
<p>  ● javascript_include_tag</p>
<p>  ● stylesheet_link_tag</p>
<p>  ● image_tag</p>
<p>  ● video_tag</p>
<p>  ● audio_tag</p>
<p>这六个帮助方法可以在布局或视图中使用，不过 auto_discovery_link_tag、javascript_include_tag 和 stylesheet_link_tag 最常出现在布局的 <head> 中。</p>
<p>静态资源标签帮助方法不会检查指定位置是否存在静态资源，假定你知道自己在做什么，只负责生成对应的链接。</p>
<p>3.1.1 使用 auto_discovery_link_tag 链接到 Feed</p>
<p>auto_discovery_link_tag 帮助方法生成的 HTML，大多数浏览器和 Feed 阅读器都能用来自动识别 RSS 或 Atom Feed。auto_discovery_link_tag 接受的参数包括链接的类型（:rss 或 :atom），传递给 url_for 的 Hash 选项，以及该标签使用的 Hash 选项：</p>
<pre><code>&lt;%= auto_discovery_link_tag(:rss, &#123;action: &quot;feed&quot;&#125;,
 &#123;title: &quot;RSS Feed&quot;&#125;) %&gt;
</code></pre>
<p>auto_discovery_link_tag 的标签选项有三个：</p>
<p>  ● :rel：指定链接 rel 属性的值，默认值为 “alternate”；</p>
<p>  ● :type：指定 MIME 类型，不过 Rails 会自动生成正确的 MIME 类型；</p>
<p>  ● :title：指定链接的标题，默认值是 :type 参数值的全大写形式，例如 “ATOM” 或 “RSS”；</p>
<p>3.1.2 使用 javascript_include_tag 链接 JavaScript 文件</p>
<p>javascript_include_tag 帮助方法为指定的每个资源生成 HTML script 标签。</p>
<p>如果启用了 Asset Pipeline，这个帮助方法生成的链接指向 &#x2F;assets&#x2F;javascripts&#x2F; 而不是 Rails 旧版中使用的 public&#x2F;javascripts。链接的地址由 Asset Pipeline 伺服。</p>
<p>Rails 程序或引擎中的 JavaScript 文件可存放在三个位置：app&#x2F;assets，lib&#x2F;assets 或 vendor&#x2F;assets。详细说明参见 Asset Pipeline 中的“静态资源的组织方式”一节。</p>
<p>文件的地址可使用相对文档根目录的完整路径，或者是 URL。例如，如果想链接到 app&#x2F;assets、lib&#x2F;assets 或 vendor&#x2F;assets 文件夹中名为 javascripts 的子文件夹中的文件，可以这么做：</p>
<pre><code>&lt;%= javascript_include_tag &quot;main&quot; %&gt;
</code></pre>
<p>Rails 生成的 script 标签如下：<br>    <script src='/assets/main.js'></script></p>
<p>对这个静态资源的请求由 Sprockets gem 伺服。</p>
<p>同时引入 app&#x2F;assets&#x2F;javascripts&#x2F;main.js 和 app&#x2F;assets&#x2F;javascripts&#x2F;columns.js 可以这么做：</p>
<pre><code>&lt;%= javascript_include_tag &quot;main&quot;, &quot;columns&quot; %&gt;
</code></pre>
<p>引入 app&#x2F;assets&#x2F;javascripts&#x2F;main.js 和 app&#x2F;assets&#x2F;javascripts&#x2F;photos&#x2F;columns.js：</p>
<pre><code>&lt;%= javascript_include_tag &quot;main&quot;, &quot;/photos/columns&quot; %&gt;
</code></pre>
<p>引入 <a href="http://example.com/main.js%EF%BC%9A">http://example.com/main.js：</a></p>
<pre><code>&lt;%= javascript_include_tag &quot;http://example.com/main.js&quot; %&gt;
</code></pre>
<p>3.1.3 使用 stylesheet_link_tag 链接 CSS 文件</p>
<p>stylesheet_link_tag 帮助方法为指定的每个资源生成 HTML <link> 标签。</p>
<p>如果启用了 Asset Pipeline，这个帮助方法生成的链接指向 &#x2F;assets&#x2F;stylesheets&#x2F;，由 Sprockets gem 伺服。样式表文件可以存放在三个位置：app&#x2F;assets，lib&#x2F;assets 或vendor&#x2F;assets。</p>
<p>文件的地址可使用相对文档根目录的完整路径，或者是 URL。例如，如果想链接到 app&#x2F;assets、lib&#x2F;assets 或 vendor&#x2F;assets 文件夹中名为 stylesheets 的子文件夹中的文件，可以这么做：</p>
<pre><code>&lt;%= stylesheet_link_tag &quot;main&quot; %&gt;
</code></pre>
<p>引入 app&#x2F;assets&#x2F;stylesheets&#x2F;main.css 和 app&#x2F;assets&#x2F;stylesheets&#x2F;columns.css：</p>
<pre><code>&lt;%= stylesheet_link_tag &quot;main&quot;, &quot;columns&quot; %&gt;
</code></pre>
<p>引入 app&#x2F;assets&#x2F;stylesheets&#x2F;main.css 和 app&#x2F;assets&#x2F;stylesheets&#x2F;photos&#x2F;columns.css：</p>
<pre><code>&lt;%= stylesheet_link_tag &quot;main&quot;, &quot;photos/columns&quot; %&gt;
</code></pre>
<p>引入 <a href="http://example.com/main.css%EF%BC%9A">http://example.com/main.css：</a></p>
<pre><code>&lt;%= stylesheet_link_tag &quot;http://example.com/main.css&quot; %&gt;
</code></pre>
<p>默认情况下，stylesheet_link_tag 创建的链接属性为 media&#x3D;”screen” rel&#x3D;”stylesheet”。指定相应的选项（:media，:rel）可以重写默认值：</p>
<pre><code>&lt;%= stylesheet_link_tag &quot;main_print&quot;, media: &quot;print&quot; %&gt;
</code></pre>
<p>3.1.4 使用 image_tag 链接图片</p>
<p>image_tag 帮助方法为指定的文件生成 HTML <img /> 标签。默认情况下，文件存放在 public&#x2F;images 文件夹中。</p>
<p>注意，必须指定图片的扩展名。</p>
<pre><code>&lt;%= image_tag &quot;header.png&quot; %&gt;
</code></pre>
<p>可以指定图片的路径：</p>
<pre><code>&lt;%= image_tag &quot;icons/delete.gif&quot; %&gt;
</code></pre>
<p>可以使用 Hash 指定额外的 HTML 属性：</p>
<pre><code>&lt;%= image_tag &quot;icons/delete.gif&quot;, &#123;height: 45&#125; %&gt;
</code></pre>
<p>可以指定一个替代文本，在关闭图片的浏览器中显示。如果没指定替代文本，Rails 会使用图片的文件名，去掉扩展名，并把首字母变成大写。例如，下面两个标签会生成相同的代码：</p>
<pre><code>&lt;%= image_tag &quot;home.gif&quot; %&gt;

&lt;%= image_tag &quot;home.gif&quot;, alt: &quot;Home&quot; %&gt;
</code></pre>
<p>还可指定图片的大小，格式为“{width}x{height}”：</p>
<pre><code>&lt;%= image_tag &quot;home.gif&quot;, size: &quot;50x20&quot; %&gt;
</code></pre>
<p>除了上述特殊的选项外，还可在最后一个参数中指定标准的 HTML 属性，例如 :class、:id 或 :name：</p>
<pre><code>&lt;%= image_tag &quot;home.gif&quot;, alt: &quot;Go Home&quot;,
 id: &quot;HomeImage&quot;,
 class: &quot;nav_bar&quot; %&gt;
</code></pre>
<p>3.1.5 使用 video_tag 链接视频</p>
<p>video_tag 帮助方法为指定的文件生成 HTML5 <video> 标签。默认情况下，视频文件存放在 public&#x2F;videos 文件夹中。</p>
<pre><code>&lt;%= video_tag &quot;movie.ogg&quot; %&gt;
</code></pre>
<p>生成的代码如下：</p>
<pre><code>&lt;video src=&quot;/videos/movie.ogg&quot; /&gt;
</code></pre>
<p>和 image_tag 类似，视频的地址可以使用绝对路径，或者相对 public&#x2F;videos 文件夹的路径。而且也可以指定 size: “#{width}x#{height}” 选项。video_tag 还可指定其他 HTML 属性，例如 id、class 等。</p>
<p>video_tag 方法还可使用 HTML Hash 选项指定所有 <video> 标签的属性，包括：</p>
<p>  ● poster: “image_name.png”：指定视频播放前在视频的位置显示的图片；</p>
<p>  ● autoplay: true：页面加载后开始播放视频；</p>
<p>  ● loop: true：视频播完后再次播放；</p>
<p>  ● controls: true：为用户提供浏览器对视频的控制支持，用于和视频交互；</p>
<p>  ● autobuffer: true：页面加载时预先加载视频文件；</p>
<p>把数组传递给 video_tag 方法可以指定多个视频：</p>
<p>&lt;%&#x3D; video_tag [“trailer.ogg”, “movie.ogg”] %&gt;</p>
<p>生成的代码如下：</p>
<pre><code>&lt;video&gt;&lt;source src=&quot;trailer.ogg&quot; /&gt;&lt;source src=&quot;movie.ogg&quot; /&gt;&lt;/video&gt;
</code></pre>
<p>3.1.6 使用 audio_tag 链接音频</p>
<p>audio_tag 帮助方法为指定的文件生成 HTML5 <audio> 标签。默认情况下，音频文件存放在 public&#x2F;audio 文件夹中。</p>
<pre><code>&lt;%= audio_tag &quot;music.mp3&quot; %&gt;
</code></pre>
<p>还可指定音频文件的路径：</p>
<pre><code>&lt;%= audio_tag &quot;music/first_song.mp3&quot; %&gt;
</code></pre>
<p>还可使用 Hash 指定其他属性，例如 :id、:class 等。</p>
<p>和 video_tag 类似，audio_tag 也有特殊的选项：</p>
<p>  ● autoplay: true：页面加载后开始播放音频；</p>
<p>  ● controls: true：为用户提供浏览器对音频的控制支持，用于和音频交互；</p>
<p>  ● autobuffer: true：页面加载时预先加载音频文件；</p>
<p>3.2 理解 yield</p>
<p>在布局中，yield 标明一个区域，渲染的视图会插入这里。最简单的情况是只有一个 yield，此时渲染的整个视图都会插入这个区域：</p>
<pre><code>&lt;html&gt;

 &lt;head&gt;

 &lt;/head&gt;

 &lt;body&gt;

 &lt;%= yield %&gt;

 &lt;/body&gt;

&lt;/html&gt;

布局中可以标明多个区域：

&lt;html&gt;

 &lt;head&gt;

 &lt;%= yield :head %&gt;

 &lt;/head&gt;

 &lt;body&gt;

 &lt;%= yield %&gt;

 &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>视图的主体会插入未命名的 yield 区域。要想在具名 yield 区域插入内容，得使用 content_for 方法。</p>
<p>3.3 使用 content_for 方法</p>
<p>content_for 方法在布局的具名 yield 区域插入内容。例如，下面的视图会在前一节的布局中插入内容：</p>
<pre><code>&lt;% content_for :head do %&gt;

 &lt;title&gt;A simple page&lt;/title&gt;

&lt;% end %&gt;



&lt;p&gt;Hello, Rails!&lt;/p&gt;
</code></pre>
<p>套入布局后生成的 HTML 如下：</p>
<pre><code>&lt;html&gt;

 &lt;head&gt;

 &lt;title&gt;A simple page&lt;/title&gt;

 &lt;/head&gt;

 &lt;body&gt;

 &lt;p&gt;Hello, Rails!&lt;/p&gt;

 &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>如果布局不同的区域需要不同的内容，例如侧边栏和底部，就可以使用 content_for 方法。content_for 方法还可用来在通用布局中引入特定页面使用的 JavaScript 文件或 CSS 文件。</p>
<p>3.4 使用局部视图</p>
<p>局部视图可以把渲染过程分为多个管理方便的片段，把响应的某个特殊部分移入单独的文件。</p>
<p>3.4.1 具名局部视图</p>
<p>在视图中渲染局部视图可以使用 render 方法：</p>
<pre><code>&lt;%= render &quot;menu&quot; %&gt;
</code></pre>
<p>渲染这个视图时，会渲染名为 _menu.html.erb 的文件。注意文件名开头的下划线：局部视图的文件名开头有个下划线，用于和普通视图区分开，不过引用时无需加入下划线。即便从其他文件夹中引入局部视图，规则也是一样：</p>
<pre><code>&lt;%= render &quot;shared/menu&quot; %&gt;
</code></pre>
<p>这行代码会引入 app&#x2F;views&#x2F;shared&#x2F;_menu.html.erb 这个局部视图。</p>
<p>3.4.2 使用局部视图简化视图</p>
<p>局部视图的一种用法是作为“子程序”（subroutine），把细节提取出来，以便更好地理解整个视图的作用。例如，有如下的视图：</p>
<pre><code>&lt;%= render &quot;shared/ad_banner&quot; %&gt;



&lt;h1&gt;Products&lt;/h1&gt;



&lt;p&gt;Here are a few of our fine products:&lt;/p&gt;

...

&lt;%= render &quot;shared/footer&quot; %&gt;
</code></pre>
<p>这里，局部视图 _ad_banner.html.erb 和 _footer.html.erb 可以包含程序多个页面共用的内容。在编写某个页面的视图时，无需关心这些局部视图中的详细内容。</p>
<p>程序所有页面共用的内容，可以直接在布局中使用局部视图渲染。</p>
<p>3.4.3 局部布局</p>
<p>和视图可以使用布局一样，局部视图也可使用自己的布局文件。例如，可以这样调用局部视图：</p>
<pre><code>&lt;%= render partial: &quot;link_area&quot;, layout: &quot;graybar&quot; %&gt;
</code></pre>
<p>这行代码会使用 _graybar.html.erb 布局渲染局部视图 _link_area.html.erb。注意，局部布局的名字也以下划线开头，和局部视图保存在同个文件夹中（不在 layouts 文件夹中）。</p>
<p>还要注意，指定其他选项时，例如 :layout，必须明确地使用 :partial 选项。</p>
<p>3.4.4 传递本地变量</p>
<p>本地变量可以传入局部视图，这么做可以把局部视图变得更强大、更灵活。例如，可以使用这种方法去除新建和编辑页面的重复代码，但仍然保有不同的内容：</p>
<pre><code>&lt;h1&gt;New zone&lt;/h1&gt;

&lt;%= render partial: &quot;form&quot;, locals: &#123;zone: @zone&#125; %&gt;

&lt;h1&gt;Editing zone&lt;/h1&gt;

&lt;%= render partial: &quot;form&quot;, locals: &#123;zone: @zone&#125; %&gt;

&lt;%= form_for(zone) do |f| %&gt;

 &lt;p&gt;

 &lt;b&gt;Zone name&lt;/b&gt;&lt;br&gt;
 &lt;%= f.text_field :name %&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;%= f.submit %&gt;
 &lt;/p&gt;
&lt;% end %&gt;
</code></pre>
<p>虽然两个视图使用同一个局部视图，但 Action View 的 submit 帮助方法为 new 动作生成的提交按钮名为“Create Zone”，为 edit 动作生成的提交按钮名为“Update Zone”。</p>
<p>每个局部视图中都有个和局部视图同名的本地变量（去掉前面的下划线）。通过 object 选项可以把对象传给这个变量：</p>
<pre><code>&lt;%= render partial: &quot;customer&quot;, object: @new_customer %&gt;
</code></pre>
<p>在 customer 局部视图中，变量 customer 的值为父级视图中的 @new_customer。</p>
<p>如果要在局部视图中渲染模型实例，可以使用简写句法：</p>
<pre><code>&lt;%= render @customer %&gt;
</code></pre>
<p>假设实例变量 @customer 的值为 Customer 模型的实例，上述代码会渲染 _customer.html.erb，其中本地变量 customer 的值为父级视图中 @customer 实例变量的值。</p>
<p>3.4.5 渲染集合<br>渲染集合时使用局部视图特别方便。通过 :collection 选项把集合传给局部视图时，会把集合中每个元素套入局部视图渲染：</p>
<pre><code>&lt;h1&gt;Products&lt;/h1&gt;
&lt;%= render partial: &quot;product&quot;, collection: @products %&gt;
&lt;p&gt;Product Name: &lt;%= product.name %&gt;&lt;/p&gt;
</code></pre>
<p>传入复数形式的集合时，在局部视图中可以使用和局部视图同名的变量引用集合中的成员。在上面的代码中，局部视图是 _product，在其中可以使用 product 引用渲染的实例。<br>渲染集合还有个简写形式。假设 @products 是 product 实例集合，在 index.html.erb 中可以直接写成下面的形式，得到的结果是一样的：</p>
<pre><code>&lt;h1&gt;Products&lt;/h1&gt;
&lt;%= render @products %&gt;
</code></pre>
<p>Rails 根据集合中各元素的模型名决定使用哪个局部视图。其实，集合中的元素可以来自不同的模型，Rails 会选择正确的局部视图进行渲染。<br>    <h1>Contacts</h1><br>    &lt;%&#x3D; render [customer1, employee1, customer2, employee2] %&gt;<br>    <p>Customer: &lt;%&#x3D; customer.name %&gt;</p><br>    <p>Employee: &lt;%&#x3D; employee.name %&gt;</p></p>
<p>在上面几段代码中，Rails 会根据集合中各成员所属的模型选择正确的局部视图。</p>
<p>如果集合为空，render 方法会返回 nil，所以最好提供替代文本。<br>    <h1>Products</h1><br>    &lt;%&#x3D; render(@products) || “There are no products available.” %&gt;</p>
<p>3.4.6 本地变量</p>
<p>要在局部视图中自定义本地变量的名字，调用局部视图时可通过 :as 选项指定：</p>
<pre><code>&lt;%= render partial: &quot;product&quot;, collection: @products, as: :item %&gt;
</code></pre>
<p>这样修改之后，在局部视图中可以使用本地变量 item 访问 @products 集合中的实例。</p>
<p>使用 locals: {} 选项可以把任意本地变量传入局部视图：</p>
<pre><code>&lt;%= render partial: &quot;product&quot;, collection: @products,
 as: :item, locals: &#123;title: &quot;Products Page&quot;&#125; %&gt;
</code></pre>
<p>在局部视图中可以使用本地变量 title，其值为 “Products Page”。</p>
<p>在局部视图中还可使用计数器变量，变量名是在集合后加上 _counter。例如，渲染 @products 时，在局部视图中可以使用 product_counter 表示局部视图渲染了多少次。不过不能和as: :value 一起使用。</p>
<p>在使用主局部视图渲染两个实例中间还可使用 :spacer_template 选项指定第二个局部视图。</p>
<p>3.4.7 间隔模板</p>
<pre><code>&lt;%= render partial: @products, spacer_template: &quot;product_ruler&quot; %&gt;
</code></pre>
<p>Rails 会在两次渲染 _product 局部视图之间渲染 _product_ruler 局部视图（不传入任何数据）。</p>
<p>3.4.8 集合局部视图的布局</p>
<p>渲染集合时也可使用 :layout 选项。</p>
<pre><code>&lt;%= render partial: &quot;product&quot;, collection: @products, layout: &quot;special_layout&quot; %&gt;
</code></pre>
<p>使用局部视图渲染集合中的各元素时会套用指定的模板。和局部视图一样，当前渲染的对象以及 object_counter 变量也可在布局中使用。</p>
<p>3.5 使用嵌套布局<br>在程序中有时需要使用不同于常规布局的布局渲染特定的控制器。此时无需复制主视图进行编辑，可以使用嵌套布局（有时也叫子模板）。下面举个例子。<br>假设 ApplicationController 布局如下：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
 &lt;title&gt;&lt;%= @page_title or &quot;Page Title&quot; %&gt;&lt;/title&gt;
 &lt;%= stylesheet_link_tag &quot;layout&quot; %&gt;
 &lt;style&gt;&lt;%= yield :stylesheets %&gt;&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
 &lt;div id=&quot;top_menu&quot;&gt;Top menu items here&lt;/div&gt;
 &lt;div id=&quot;menu&quot;&gt;Menu items here&lt;/div&gt;
 &lt;div id=&quot;content&quot;&gt;&lt;%= content_for?(:content) ? yield(:content) : yield %&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 NewsController 的页面中，想隐藏顶部目录，在右侧添加一个目录：</p>
<pre><code>&lt;% content_for :stylesheets do %&gt;
#top_menu &#123;display: none&#125;
#right_menu &#123;float: right; background-color: yellow; color: black&#125;
&lt;% end %&gt;
&lt;% content_for :content do %&gt;
&lt;div id=&quot;right_menu&quot;&gt;Right menu items here&lt;/div&gt;
&lt;%= content_for?(:news_content) ? yield(:news_content) : yield %&gt;
&lt;% end %&gt;
&lt;%= render template: &quot;layouts/application&quot; %&gt;
</code></pre>
]]></content>
      <categories>
        <category>RubyOnRails</category>
      </categories>
  </entry>
  <entry>
    <title>[RubyOnRails]Ruby Array学习总结</title>
    <url>/2013/05/07/Ruby%20Array%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Array</p>
<p>&amp;取两数组相同</p>
<p>*数组相乘</p>
<p>+数组相加</p>
<p>-[1,2,3]-[1,2,4] &#x3D; [3]</p>
<p>&lt;&lt;追加</p>
<p>&lt;&#x3D;&gt;比较每个元素 小于-1等于0大于1(每个元素比较)</p>
<p>to_ary转换成数组</p>
<p>&#x3D;&#x3D;相等</p>
<p>[]        下标引用。a&#x3D;[1,2,3,4].a[1]下标为1的元素,a[1,3]从下标为1顺序取三个,a[1..3]1-3的元素.特殊 a[4]&#x3D;&gt;nil, a[4..6]&#x3D;&gt;[], a[5..7] &#x3D;&gt; nil</p>
<p>[]&#x3D;        赋值</p>
<p>｜并集操作,也就是把不同的组合在一起</p>
<p>assoc(‘a’)    匹配子数组第一个元素,匹配到返回子数组，否则nil不匹配字符串</p>
<p>at        返回下标处元素,比[]快，不支持range(范围,例:1..5)参数</p>
<p>clear        清楚数组</p>
<p>collect收集    对每个元素调用block。！号模式替换原来的，此拷贝原来数组</p>
<p>compact压缩    去掉nil,有！号模式</p>
<p>concat        追加后面的数组</p>
<p>delete        删除指定元素，返回删除元素,数组没有指定的元素返回nil，有block返回block[1,2].delete(1) {“sorry”}</p>
<p>delete_at     删除指定下标的</p>
<p>delete_if    有条件删除，调用block,返回剩余元素</p>
<p>each        循环数组</p>
<p>each_index    循环下标</p>
<p>empty?        判断是否为空</p>
<p>eql?        比较</p>
<p>fetch取来    用法a&#x3D;[1,2,3] a.fetck(1)&#x3D;&gt;2,a.fetch(1,”b”)&#x3D;&gt;1,a.fetch(5,”b”)&#x3D;&gt;b,a.fetch(5){|i|i*i}&#x3D;&gt;25</p>
<p>fill填充,装满    参数型式(obj),(obj,range(范围)),{|i| i代表下标},(range){|i|操作}</p>
<p>flatten        扁平数组,!号模式</p>
<p>include?    包含 true or false</p>
<p>index        返回下标或nil</p>
<p>insert        插入只能指定下标，不能指定下标范围</p>
<p>join        合并，后面可以加参数(‘-‘)</p>
<p>last        返回最后一个，也可以加返回最后几个</p>
<p>length        数组长度</p>
<p>map        和collect同义</p>
<p>nitems        返回非nil的长度</p>
<p>pop        删除数组最后一个元素并返回,nil也返回nil</p>
<p>push        将指定参数加到数组中,可以任何对象</p>
<p>rassoc        不怎么明白有何用</p>
<p>reject        等同于delete_if</p>
<p>replace取代    替换元素</p>
<p>reverse相反    反序有！模式</p>
<p>reverse_each    逆序遍历数组</p>
<p>rindex        删除数组的最后一个指定的对象，没有返回nil</p>
<p>shift        删除第一个</p>
<p>slice        于[]同义</p>
<p>slice!        删除给定的索引，参数是range</p>
<p>sort        排序,有！模式</p>
<p>to_a,to_ary    转换成数组</p>
<p>tracspose    二维数组更换行和列</p>
<p>uniq        删除重复元素，有！模式</p>
<p>unshift        添加对象到数组首部</p>
<p>values_at    参数下标，返回数组。可以是范围</p>
]]></content>
      <categories>
        <category>RubyOnRails</category>
      </categories>
  </entry>
  <entry>
    <title>[RubyOnRails]Ubuntu下Rails开发环境配置</title>
    <url>/2013/05/07/Ubuntu%20%E4%B8%8A%20Rails%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Ubuntu版本：14.04</p>
<p>Ruby版本：2.1.2</p>
<p>1、 更新apt-get：</p>
<p>ubuntu@ubuntu:~$ sudo apt-get update</p>
<p>2、 安装curl：</p>
<p>ubuntu@ubuntu:~$ sudo apt-get install curl</p>
<p>3、 安装rvm：</p>
<p>安装：ubuntu@ubuntu:~$ curl -L <a href="https://get.rvm.io/">https://get.rvm.io</a> | bash -s stable</p>
<p>配置：ubuntu@ubuntu:~$ source ~&#x2F;.rvm&#x2F;scripts&#x2F;rvm</p>
<p>查看：<br>ubuntu@ubuntu:~$ rvm -v</p>
<p>rvm 1.25.33 (stable) by Wayne E. Seguin <a href="mailto:&#119;&#x61;&#121;&#x6e;&#x65;&#101;&#x73;&#x65;&#x67;&#x75;&#105;&#x6e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#119;&#x61;&#121;&#x6e;&#x65;&#101;&#x73;&#x65;&#x67;&#x75;&#105;&#x6e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>, Michal Papis <a href="mailto:&#109;&#x70;&#x61;&#x70;&#105;&#115;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;">&#109;&#x70;&#x61;&#x70;&#105;&#115;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a> [<a href="https://rvm.io/]">https://rvm.io/]</a></p>
<p>4、 安装ruby：</p>
<p>要先执行下面命令，否则后边流程跑不动：</p>
<p>ubuntu@ubuntu:~$ rvm autolibs enable</p>
<p>下面这步可选，是将rvm的源改成国内taobao的源：</p>
<p>ubuntu@ubuntu:~$ sed -i .bak ‘s!ftp.ruby-lang.org&#x2F;pub&#x2F;ruby!ruby.taobao.org&#x2F;mirrors&#x2F;ruby!’ $rvm_path&#x2F;config&#x2F;db</p>
<p>安装：</p>
<p>ubuntu@ubuntu:<del>$ rvm pkg install readline<br>ubuntu@ubuntu:</del>$ rvm install 2.1.2 （此步需要耗费一定时间）<br>ubuntu@ubuntu:~$ rvm 2.1.2 –default</p>
<p>5、 更改gem源：</p>
<p>国外的源可选，若删除的话执行：<br>ubuntu@ubuntu:<del>$ gem source -r <a href="https://rubygems.org/">https://rubygems.org/</a><br>添加国内的源：<br>ubuntu@ubuntu:</del>$ gem source -a <a href="https://ruby.taobao.org/">https://ruby.taobao.org/</a></p>
<p>6、 安装rails：</p>
<p>ubuntu@ubuntu:~$ gem install rails</p>
<p>下面就可以创建一个”blog”程序尝试一下：</p>
<p>1、参照<a href="http://guides.ruby-china.org/getting_started.html">http://guides.ruby-china.org/getting_started.html</a> 创建blog程序</p>
<p>2、启动服务器（执行 rails server）时会有如下报错：</p>
<p>&#x2F;home&#x2F;ubuntu&#x2F;.rvm&#x2F;gems&#x2F;ruby-2.1.2&#x2F;gems&#x2F;execjs-2.2.2&#x2F;lib&#x2F;execjs&#x2F;runtimes.rb:51:in &#96;autodetect’: Could not find a JavaScript runtime. See <a href="https://github.com/sstephenson/execjs">https://github.com/sstephenson/execjs</a> for a list of available runtimes. (ExecJS::RuntimeUnavailable)</p>
<p>解决方法：<br>gem install execjs<br>gem install therubyracer<br>sudo apt-get install nodejs</p>
<p>再次启动服务器，即可正常运行啦！！！</p>
]]></content>
      <categories>
        <category>RubyOnRails</category>
      </categories>
  </entry>
  <entry>
    <title>[Php]Ubuntu下为PHP安装postgis，pdo_pgsql，composer</title>
    <url>/2015/05/16/Ubuntu%E4%B8%8B%E4%B8%BAPHP%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>安装postgis：</p>
<p>sudo apt-get install postgresql postgresql-contrib postgis postgresql-9.3-postgis-2.1</p>
<p>安装pdo-pqsql：</p>
<p>sudo apt-get install php5-pgsql</p>
<p>测试pdo：</p>
<p>new PDO(“pgsql:host&#x3D;127.0.0.1;dbname&#x3D;test”,  “postgres”,  “root”); die(“1111111”);</p>
<p>安装composer：</p>
<p>curl -sS <a href="https://getcomposer.org/installer">https://getcomposer.org/installer</a> | php</p>
<p>mv composer.phar &#x2F;usr&#x2F;local&#x2F;bin&#x2F;composer</p>
<p>项目下：</p>
<p>composer install （composer install -vvv）</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>[Node]Ubuntu下安装n管理node版本</title>
    <url>/2022/07/05/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85n%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>安装node的n模块</p>
<pre><code>sudo npm install -g n
</code></pre>
<p>安装最新的版本</p>
<pre><code>$ n latest
</code></pre>
<p>安装稳定版本</p>
<pre><code>$ n stable
</code></pre>
<p>删除某个版本</p>
<pre><code>$ n rm 0.10.1
</code></pre>
<p>以指定的版本来执行脚本</p>
<pre><code>$ n use 0.10.21 some.js
</code></pre>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>[VueJs]Ubuntu下安装配置vuejs</title>
    <url>/2022/07/05/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEvuejs/</url>
    <content><![CDATA[<p><a href="https://github.com/vuejs">https://github.com/vuejs</a></p>
<p>第一步，安装npm</p>
<p>第二步，安装webpack</p>
<p>npm init(初始化，会生成一个package.json文件)</p>
<p>npm install webpack -g</p>
<p>npm install webpack –save-dev</p>
<p>使用指定版本</p>
<p> npm install <a href="mailto:&#119;&#x65;&#98;&#112;&#97;&#99;&#107;&#64;&#49;&#x2e;&#50;&#x2e;&#x78;">&#119;&#x65;&#98;&#112;&#97;&#99;&#107;&#64;&#49;&#x2e;&#50;&#x2e;&#x78;</a> –save-dev</p>
<p>第三步，安装vue</p>
<p>npm install vue</p>
<p>npm install vue@csp</p>
<p>安装官方命令行工具</p>
<p>npm install -g vue-cli</p>
<p>第四步，创建一个基于 “webpack” 模板的新项目</p>
<p>vue init webpack my-project</p>
<p>cd my-project</p>
<p> npm install</p>
<p> npm run dev</p>
<p>错误：vuejs &#x2F;usr&#x2F;bin&#x2F;env: “node”: 没有那个文件或目录</p>
<p>解决办法：sudo apt-get install nodejs-legacy(如果没有安装nodejs也是需要安装的)</p>
]]></content>
      <categories>
        <category>VUEJS</category>
      </categories>
  </entry>
  <entry>
    <title>[Android]Ubuntu安装Gradle</title>
    <url>/2022/07/05/Ubuntu%E5%AE%89%E8%A3%85gradle/</url>
    <content><![CDATA[<p>安装gradle：</p>
<p>curl -s <a href="https://get.sdkman.io/">https://get.sdkman.io</a> | bash</p>
<p>sdk install gradle 2.14.1</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>[MySql]Ubuntu系统mysql用户root空密码登录</title>
    <url>/2022/07/05/Ubuntu%E7%B3%BB%E7%BB%9Fmysql%E7%94%A8%E6%88%B7root%E7%A9%BA%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>执行：</p>
<p>sudo mysqld_safe –user&#x3D;mysql –skip-grant-tables –skip-networking &amp;</p>
<p>新打开一个窗口：</p>
<p>mysql -uroot -p</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
  </entry>
  <entry>
    <title>[android] 对于webview中type为file无法选择文件以及上传</title>
    <url>/2017/03/01/android%E4%B8%AD%E5%AF%B9%E4%BA%8Ewebview%E4%B8%ADtype%E4%B8%BAfile%E6%97%A0%E6%B3%95%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>android部分， 通过setWebChromeClient实现文件选择：</p>
<pre><code>    WebSettings settings = webview.getSettings();
    settings.setUseWideViewPort(true);
    settings.setLoadWithOverviewMode(true);
    settings.setJavaScriptEnabled(true);
    webview.setWebChromeClient(new WebChromeClient() &#123;

        // For Android &lt; 3.0
        public void openFileChooser(ValueCallback&lt;Uri&gt; valueCallback) &#123;
            uploadMessage = valueCallback;
            openImageChooserActivity();
        &#125;

        // For Android  &gt;= 3.0
        public void openFileChooser(ValueCallback valueCallback, String acceptType) &#123;
            uploadMessage = valueCallback;
            openImageChooserActivity();
        &#125;

        //For Android  &gt;= 4.1
        public void openFileChooser(ValueCallback&lt;Uri&gt; valueCallback, String acceptType, String capture) &#123;
            uploadMessage = valueCallback;
            openImageChooserActivity();
        &#125;

        // For Android &gt;= 5.0
        @Override
        public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) &#123;
            uploadMessageAboveL = filePathCallback;
            openImageChooserActivity();
            return true;
        &#125;
    &#125;);



            private void openImageChooserActivity() &#123;
                Intent i = new Intent(Intent.ACTION_GET_CONTENT);
                i.addCategory(Intent.CATEGORY_OPENABLE);
                i.setType(&quot;image/*&quot;);
                startActivityForResult(Intent.createChooser(i, &quot;Image Chooser&quot;), FILE_CHOOSER_RESULT_CODE);
            &#125;

            @Override
            protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
                super.onActivityResult(requestCode, resultCode, data);
                if (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;
                    if (null == uploadMessage &amp;&amp; null == uploadMessageAboveL) return;
                    Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();
                    if (uploadMessageAboveL != null) &#123;
                        onActivityResultAboveL(requestCode, resultCode, data);
                    &#125; else if (uploadMessage != null) &#123;
                        uploadMessage.onReceiveValue(result);
                        uploadMessage = null;
                    &#125;
                &#125;
            &#125;

            @TargetApi(Build.VERSION_CODES.LOLLIPOP)
            private void onActivityResultAboveL(int requestCode, int resultCode, Intent intent) &#123;
                if (requestCode != FILE_CHOOSER_RESULT_CODE || uploadMessageAboveL == null)
                    return;
                Uri[] results = null;
                if (resultCode == Activity.RESULT_OK) &#123;
                    if (intent != null) &#123;
                        String dataString = intent.getDataString();
                        ClipData clipData = intent.getClipData();
                        if (clipData != null) &#123;
                            results = new Uri[clipData.getItemCount()];
                            for (int i = 0; i &lt; clipData.getItemCount(); i++) &#123;
                                ClipData.Item item = clipData.getItemAt(i);
                                results[i] = item.getUri();
                            &#125;
                        &#125;
                        if (dataString != null)
                            results = new Uri[]&#123;Uri.parse(dataString)&#125;;
                    &#125;
                &#125;
                uploadMessageAboveL.onReceiveValue(results);
                uploadMessageAboveL = null;
            &#125;
</code></pre>
<p>webview部分：</p>
<pre><code>    &lt;input @change=&quot;change_icon&quot; type=&quot;file&quot; id=&quot;file-input&quot; style=&quot;width: 20%;
      float: right;
      opacity: 0;
      height: 154%;
      margin-left: 5%;
      border-radius: 45px;
      margin-top: -6%;&quot; /&gt;


             change_icon (e) &#123;
                    console.log(&#39;进入了change_icon----------&#39;)
                    console.info(&#39;change icon&#39;)
                    var files = e.target.files || e.dataTransfer.files;
                    console.log(&#39;--------------files.length==&#39; + files.length)
                    if (!files.length)
                        return;
                    var reader = new FileReader();
                    var vm = this
                    reader.onload = (e) =&gt; &#123;
                        this.$http.post(
                          &#39;api/interface/users/update_user_icon&#39;, &#123;
                             icon: e.target.result,
                            //icon: data,
                            id: this.$store.state.userInfo.id,
                        &#125;).then((response) =&gt; &#123;
                          console.log(&#39;=====上传成功了=====&#39;)
                          console.log(response.body)
                          vm.icon = response.body.icon
                        &#125;, (error) =&gt; &#123;
                          console.error(error)
                          console.log(&#39;=====上传失败了=====&#39;)
                        &#125;);
                    &#125;;
                    reader.readAsDataURL(files[0]);
             &#125;
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>[android] 使用HttpURLConnection发送请求</title>
    <url>/2017/02/28/android%E4%BD%BF%E7%94%A8HttpURLConnection%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>android部分, 需要使用URLEncoder.encode单独对中文参数部分进行编码(URLDecoder.decode(name, “UTF-8”);   可以将url中的编码转译)</p>
<pre><code>public String getCityIdByName() &#123;
    Log.d(TAG, &quot;方法==getCityIdByName===cityName是===&quot; + cityName);

    //在子线程中操作网络请求
    new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
            //urlConnection请求服务器，验证
            try &#123;
                //1：url对象

                URL url = new URL(PageUrls.SERVER_URL + &quot;/interface/cities/get_city_id_by_name?name=&quot; + URLEncoder.encode(cityName));
                Log.d(TAG, &quot;==========================url=&quot; + url);
                //2;url.openconnection
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                //3
                conn.setRequestMethod(&quot;GET&quot;);
                conn.setConnectTimeout(10 * 1000);
                //4
                int code = conn.getResponseCode();
                Log.d(TAG, &quot;=====code====&quot; + code);
                if (code == 200) &#123;
                    InputStream inputStream = conn.getInputStream();
                    byte[] result = HttpURLConnHelper.streamToByte(new BufferedInputStream(inputStream));
                    Log.d(TAG, &quot;=====================服务器返回的信息：：&quot; + result);


                    JSONObject obj1 = new JSONObject(new String(result, &quot;utf-8&quot;));
                    Log.d(TAG, &quot;处理后的返回结果为===&quot; + obj1);

                    Message message = Message.obtain();
                    message.what = 5;
                    message.obj = obj1.getString(&quot;city_id&quot;);
                    handler.sendMessage(message);
                &#125;
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;).start();


    return cityId;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>[android] android使用umeng分享</title>
    <url>/2017/05/02/android%E4%BD%BF%E7%94%A8umeng%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<pre><code>    微信支付包会和umeng分享包冲突，删除掉微信支付包就可以了libammsdk.jar

    /**********************************配置部分AndroidManifest.xml************************************/

&lt;!--添加友盟appkey--&gt;
&lt;meta-data
    android:name=&quot;UMENG_APPKEY&quot;
    android:value=&quot;你申请的umeng的appkey&quot; &gt;
&lt;/meta-data&gt;

&lt;!--新浪--&gt;
&lt;activity
    android:name=&quot;.WBShareActivity&quot;
    android:configChanges=&quot;keyboardHidden|orientation&quot;
    android:screenOrientation=&quot;portrait&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.sina.weibo.sdk.action.ACTION_SDK_REQ_ACTIVITY&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;activity
    android:name=&quot;com.sina.weibo.sdk.component.WeiboSdkBrowser&quot;
    android:configChanges=&quot;keyboardHidden|orientation&quot;
    android:windowSoftInputMode=&quot;adjustResize&quot;
    android:exported=&quot;false&quot; &gt;
&lt;/activity&gt;
&lt;service android:name=&quot;com.sina.weibo.sdk.net.DownloadService&quot;
    android:exported=&quot;false&quot;&gt;&lt;/service&gt;

&lt;!--微信--&gt;
&lt;activity
    android:name=&quot;.wxapi.WXEntryActivity&quot;
    android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;
    android:exported=&quot;true&quot;
    android:screenOrientation=&quot;portrait&quot;
    android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot; /&gt;
    application标签添加android:name=&quot;.App&quot;属性

//完成App.java
    package com.****;

    import android.app.Activity;
    import android.app.Application;
    import android.os.Bundle;

    import com.umeng.socialize.Config;
    import com.umeng.socialize.PlatformConfig;
    import com.umeng.socialize.UMShareAPI;
    import com.umeng.socialize.common.QueuedWork;


    public class App extends Application &#123;

            @Override
            public void onCreate() &#123;

                super.onCreate();
                //开启debug模式，方便定位错误，具体错误检查方式可以查看http://dev.umeng.com/social/android/quick-integration的报错必看，正式发布，请关闭该模式
                Config.DEBUG = true;
                QueuedWork.isUseThreadPool = false;
                UMShareAPI.get(this);
            &#125;

            //各个平台的配置，建议放在全局Application或者程序入口
            &#123;
                PlatformConfig.setWeixin(&quot;wx07db41d675c7396c&quot;, &quot;31cdc662cac10fe53f64356af9b6c32a&quot;);
                //豆瓣RENREN平台目前只能在服务器端配置
                PlatformConfig.setSinaWeibo(&quot;3921700954&quot;, &quot;04b48b094faeb16683c32669824ebdad&quot;,&quot;http://sns.whalecloud.com&quot;);
                    //        PlatformConfig.setYixin(&quot;yxc0614e80c9304c11b0391514d09f13bf&quot;);
                    //        PlatformConfig.setQQZone(&quot;100424468&quot;, &quot;c7394704798a158208a74ab60104f0ba&quot;);
                    //        PlatformConfig.setTwitter(&quot;3aIN7fuF685MuZ7jtXkQxalyi&quot;, &quot;MK6FEYG63eWcpDFgRYw4w9puJhzDl0tyuqWjZ3M7XJuuG7mMbO&quot;);
                    //        PlatformConfig.setAlipay(&quot;2015111700822536&quot;);
                    //        PlatformConfig.setLaiwang(&quot;laiwangd497e70d4&quot;, &quot;d497e70d4c3e4efeab1381476bac4c5e&quot;);
                    //        PlatformConfig.setPinterest(&quot;1439206&quot;);
                    //        PlatformConfig.setKakao(&quot;e4f60e065048eb031e235c806b31c70f&quot;);
                    //        PlatformConfig.setDing(&quot;dingoalmlnohc0wggfedpk&quot;);
                    //        PlatformConfig.setVKontakte(&quot;5764965&quot;,&quot;5My6SNliAaLxEm3Lyd9J&quot;);
                    //        PlatformConfig.setDropbox(&quot;oz8v5apet3arcdy&quot;,&quot;h7p2pjbzkkxt02a&quot;);

            &#125;
    &#125;


    /***********************************准备好分享所需的activity************************************/
//新浪分享activity

    package com.******;//import com.umeng.socialize.media.WBShareCallBackActivity;

    import com.umeng.socialize.media.WBShareCallBackActivity;


    public class WBShareActivity extends WBShareCallBackActivity &#123;
    &#125;


//微信分享activity,这块一定要注意要放在com.***.wxapi包下
    package com.****.wxapi;


    //import com.umeng.weixin.callback.WXCallbackActivity;

    import com.umeng.socialize.weixin.view.WXCallbackActivity;

    public class WXEntryActivity extends WXCallbackActivity &#123;



    &#125;

    /***********************分享按钮点击事件，分享开始, 为需要分享的按钮添加一个onclick事件，id为fenxiangBtn***********/


UMShareListener umShareListener = new UMShareListener() &#123;
    @Override
    public void onStart(SHARE_MEDIA platform) &#123;
    &#125;

    @Override
    public void onResult(SHARE_MEDIA platform) &#123;
        Toast.makeText(MineActivity.this, &quot;分享成功.&quot;, Toast.LENGTH_LONG).show();
    &#125;

    @Override
    public void onError(SHARE_MEDIA platform, Throwable t) &#123;
    &#125;

    @Override
    public void onCancel(SHARE_MEDIA platform) &#123;
        Toast.makeText(MineActivity.this, &quot;取消分享.&quot;, Toast.LENGTH_LONG).show();
    &#125;
&#125;;


public void fenxiangClick(View view)&#123;
    switch (view.getId()) &#123;
        case R.id.fenxiangBtn:

            UMWeb web = new UMWeb(&quot;分享出去之后，点击所跳转的地址&quot;);
            web.setTitle(&quot;分享标题&quot;);//标题
            web.setThumb(new UMImage(MineActivity.this, R.mipmap.icon));  //缩略图
            web.setDescription(&quot;分享文字描述&quot;);//描述

            //打开分享面板
            new ShareAction(MineActivity.this).withText(&quot;分享文字描述&quot;)
                    .withMedia(web)
                                            //分享面板中显示分享到微信朋友圈，分享给微信好友，分享到新浪微搏
                    .setDisplayList(SHARE_MEDIA.SINA,SHARE_MEDIA.WEIXIN_CIRCLE,SHARE_MEDIA.WEIXIN)
                    .setCallback(umShareListener).open();
            break;
    &#125;
&#125;

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    super.onActivityResult(requestCode, resultCode, data);
    UMShareAPI.get(this).onActivityResult(requestCode, resultCode, data);

&#125;

/**
 * 内存泄漏
 */
@Override
protected void onDestroy() &#123;
    super.onDestroy();
    UMShareAPI.get(this).release();
&#125;

/**
 * qq微信新浪授权防杀死
 * @param outState
 */
    @Override
    protected void onSaveInstanceState(Bundle outState) &#123;
            super.onSaveInstanceState(outState);
            UMShareAPI.get(this).onSaveInstanceState(outState);
    &#125;


    /*******************res显示面板********************/
    使用的官网提供的面板socialize_share_menu_item.xml，umeng_socialize_oauth_dialog.xml
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>[android] 图标桌面不显示的问题解决</title>
    <url>/2017/02/25/android%E5%9B%BE%E6%A0%87%E6%A1%8C%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<pre><code>        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>[Ruby On Rails] app微信支付Ruby on Rails接口篇</title>
    <url>/2017/03/15/app%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98Ruby%20on%20Rails%E6%8E%A5%E5%8F%A3%E7%AF%87/</url>
    <content><![CDATA[<pre><code>    使用gem &#39;wx_pay&#39;


    payments_controller


    def information

        trade_type = params[:trade_type]
        WxPay.appid = Settings.wx_pay.android_and_ios.appid
        WxPay.key = Settings.wx_pay.android_and_ios.key
        WxPay.mch_id = Settings.wx_pay.android_and_ios.mch_id

        #开启调试模式
        WxPay.debug_mode = true

        Rails.logger.info &quot;trade_type===#&#123;trade_type&#125;&quot;
        Rails.logger.info &quot;appid===#&#123;Settings.wx_pay.android_and_ios.appid&#125;&quot;
        Rails.logger.info &quot;key===#&#123;Settings.wx_pay.android_and_ios.key&#125;&quot;
        Rails.logger.info &quot;mch_id===#&#123;Settings.wx_pay.android_and_ios.mch_id&#125;&quot;

        fee = params[:fee]
        order_sn = params[:order_sn]

        # 订单号, 需要每次都要变化.
        @order = Order.includes(:good).find(params[:order_id])

        payment_params = &#123;
            body: &quot;商品名称: #&#123;@order.good.name&#125;, 总价: #&#123;fee&#125;元&quot;,
            out_trade_no: order_sn,
            # 单位是 分, 所以要 乘以 100
            total_fee: (fee.to_f * 100).to_i,

            # 我们服务器的 IP
            spbill_create_ip: Settings.wx_pay.spbill_create_ip,
            # 微信服务器 在支付成功后, 调用我们服务器的接口, 来告诉我们.
            notify_url: Settings.wx_pay.notify_url,
            trade_type: trade_type, #&#39;JSAPI&#39;, # could be &quot;JSAPI&quot;, &quot;NATIVE&quot; or &quot;APP&quot;,
            # 用户的open id
            #openid: params[:open_id]  # 当支付方式是 公众号内支付的时候, 用这个.
        &#125;
        Rails.logger.info &quot;== payment_params: #&#123;payment_params.inspect&#125;&quot;

        # 第一次访问微信服务器, 主要目的是获取 prepay_id, 在这个r 中,  r[&#39;prepay_id&#39;] 就是微信返回的值

        r = WxPay::Service.invoke_unifiedorder payment_params

        Rails.logger.info &quot;== information-: #&#123;r.inspect&#125;&quot;

        # 准备为第二次 访问 微信服务器做准备.
        if r.success? # =&gt; true
            @order.update_attribute(&#39;collect&#39;, fee)
            temp_return_code =  r[&quot;return_code&quot;]
            temp_return_msg =  r[&quot;return_msg&quot;]


            params_for_app = &#123;
              prepayid: r[&#39;prepay_id&#39;],
              noncestr: SecureRandom.uuid.tr(&#39;-&#39;, &#39;&#39;)
            &#125;

            # 第二次访问 微信服务器, 获取 app 支付所需要的参数:
            # 臭名昭著的 sign 问题就是在这个方法中被解决( 应该是还需要把sign 重新生成一遍)
            # 多亏有这个gem, 我们不必顾虑这个问题了.
            #

            r = WxPay::Service.generate_app_pay_req params_for_app

            Rails.logger.info &quot;==== generate_app_pay_req : #&#123;r.inspect&#125;&quot;

            result = &#123;
              appId: r[:appid],
              partnerid: r[:partnerid],
              prepay_id: r[:prepayid],
              package: r[:package],
              timeStamp: r[:timestamp],
              nonceStr: r[:noncestr],
              return_code: temp_return_code,  # 这个参数没太大用. 我们项目使用而已.
              return_msg: temp_return_msg,# 这个参数没太大用. 我们项目使用而已.
              sign: r[:sign],
              order_id: @order.id
            &#125;
        else
            result = &#123; return_code: r[&quot;return_code&quot;], return_msg: r[&quot;return_msg&quot;], result_code: r[&quot;result_code&quot;], err_code: r[&quot;err_code&quot;], err_code_des: r[&quot;err_code_des&quot;] &#125;
        end

        Rails.logger.info &quot;== 最终返回给app的结果 final_result :--#&#123;result.inspect&#125;-------&quot;

        render json: result
    end

    def notify
        logger.info &quot;== notify from weixin server: &quot;
        logger.info params.inspect
        logger.info &quot;== notify from weixin server( done ) : &quot;

        # 请求是由 微信服务器 发送过来.
        result = Hash.from_xml(request.body.read)[&quot;xml&quot;]

        Rails.logger.info &quot;----notify-----result------#&#123;result&#125;-------&quot;
        if WxPay::Sign.verify?(result)
            order_number = result[&quot;out_trade_no&quot;].to_s
            logger.info &quot;==  sign verified&quot;
            Rails.logger.info &quot;---------order_no------#&#123;result[&quot;out_trade_no&quot;]&#125;-------&quot;
            @order = Order.find_by_order_number(order_number)
            logger.info &quot;==  #&#123;@order.inspect&#125; order !!!!!----&quot;
            unless @order.blank?
              logger.info &quot;==  order is not blank !!!!!----&quot;
              time = Time.now.to_datetime
              @order.update_attributes(:order_status =&gt; &#39;yizhifu&#39;, :collect =&gt; result[&quot;total_fee&quot;], :payed_at =&gt; time)
            end
            render :xml =&gt; &#123; return_code: &quot;SUCCESS&quot; &#125;.to_xml(root: &#39;xml&#39;, dasherize: false)
        else
            logger.error &quot;==  sign NOT verified&quot;
            render :xml =&gt; &#123; return_code: &quot;FAIL&quot;, return_msg: &quot;&quot; &#125;.to_xml(root: &#39;xml&#39;, dasherize: false)
        end
    end
</code></pre>
]]></content>
      <categories>
        <category>Ruby On Rails</category>
      </categories>
  </entry>
  <entry>
    <title>[android] app微信支付android篇</title>
    <url>/2017/03/15/app%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98android%E7%AF%87/</url>
    <content><![CDATA[<p>h5上需要提供一个javascript方法 ：</p>
<pre><code>  global_function_weixin_pay = function () &#123;
    return &#39;http://api.****.com/interface/payments/information?&#39; + &#39;order_id=&#39; + that.order.order_id + &#39;&amp;fee=&#39; + that.order.amount + &#39;&amp;order_sn=&#39; + that.order.order_number + &#39;&amp;trade_type=APP&#39;
  &#125;
</code></pre>
<p>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>购买商品的activity</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>*****&#x2F;</p>
<pre><code>private String translateHtmlStringToLocal(String value) &#123;
    return value.replace(&quot;\&quot;&quot;, &quot;&quot;);
&#125;

public class shopShowWebViewClient extends WebViewClient &#123;

    @TargetApi(Build.VERSION_CODES.KITKAT)
    @Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;
        Log.d(TAG, &quot;ShopShowActivity shouldOverrideUrlLoading====&quot; + url);
        //微信支付，h5请求的地址必须是带域名的
        Pattern pattern = Pattern.compile(&quot;http://h5.shangyunyijia.com/run_native_pay&quot;);
        Matcher matcher = pattern.matcher(url);
        if (matcher.find()) &#123;
            Log.d(TAG, &quot;微信开始支付&quot;);
            shopShowWebView.evaluateJavascript(&quot;global_function_weixin_pay()&quot;, new ValueCallback&lt;String&gt;() &#123;
                @Override
                public void onReceiveValue(String value) &#123;
                    Log.d(TAG, &quot;global_function_weixin_pay value=&quot; + value);
                    if (!value.contains(&quot;null&quot;) &amp;&amp; !value.contains(&quot;NULL&quot;)) &#123;
                        String payUrl = translateHtmlStringToLocal(value);
                        getPayInfoFromServer(payUrl);
                    &#125;
                &#125;
            &#125;);
            return true;
        &#125;

        view.loadUrl(url);

        return false;
    &#125;

    @Override
    public void onPageFinished(WebView view, String url) &#123;
        super.onPageFinished(view, url);

        Log.d(TAG, &quot;onPageFinished, 触发的url是====&quot; + url);

        Log.d(TAG, &quot;取消小菊花开始...&quot;);
        // 取消小菊花 放在这里才可以.   针对myorder  打开的时候小菊花不会消失。
        try &#123;
            dismissLoadingDialog();
        &#125; catch (Exception e) &#123;
            try &#123;
                dismissLoadingDialog();
            &#125; catch (Exception e2) &#123;
                Log.e(TAG, &quot;== 取消小菊花出错了: &quot; + e.toString());
            &#125;
        &#125;
    &#125;
&#125;



/**
 * 微信获取支付信息
 * @param payUrl
 */
public void getPayInfoFromServer(final String payUrl) &#123;

    if (this != null) &#123;
        this.showLoadingDialog();
    &#125;

    com.lidroid.xutils.HttpUtils http = new com.lidroid.xutils.HttpUtils();
    http.send(HttpRequest.HttpMethod.GET,
            payUrl,
            null,
            new RequestCallBack&lt;String&gt;() &#123;
                @Override
                public void onSuccess(ResponseInfo&lt;String&gt; responseInfo) &#123;

                    if (ShopShowActivity.this != null) &#123;
                        ShopShowActivity.this.dismissLoadingDialog();
                    &#125;

                    if (responseInfo != null &amp;&amp; responseInfo.result != null) &#123;

                        WeiXinPayBean weiXinPayBean = JSON.parseObject(responseInfo.result, WeiXinPayBean.class);
                        Log.d(TAG, &quot;ShopShowActivity=== getPayInfoFromServer() =========onSuccess(ResponseInfo&lt;String&gt; responseInfo)&quot; + weiXinPayBean.getReturn_code().toUpperCase());

                        if (weiXinPayBean.getReturn_code().toUpperCase().equals(&quot;SUCCESS&quot;)) &#123;
                            WXPayEntryActivity.show(ShopShowActivity.this, weiXinPayBean, REQUEST_WEIXIN_PAY);
</code></pre>
<p>&#x2F;&#x2F;                                Intent intent &#x3D; new Intent(ShopShowActivity.this, WXPayEntryActivity.class);<br>&#x2F;&#x2F;                                intent.putExtra(“weiXinPayBean”, weiXinPayBean);<br>&#x2F;&#x2F;                                startActivityForResult(intent, REQUEST_WEIXIN_PAY);</p>
<pre><code>                            //WXPayEntryActivity.show(OrderPaySuccessFragment.newInstance(pageUrl, &quot;支付成功&quot;, true), weiXinPayBean, REQUEST_WEIXIN_PAY);
                        &#125; else &#123;
                            Toast.makeText(ShopShowActivity.this, weiXinPayBean.getErr_code_des(), Toast.LENGTH_SHORT).show();
                        &#125;
                    &#125; else &#123;
                        Toast.makeText(ShopShowActivity.this, &quot;获取支付信息失败&quot;, Toast.LENGTH_SHORT).show();
                    &#125;
                &#125;

                @Override
                public void onFailure(HttpException e, String s) &#123;
                    Log.d(TAG, &quot;=========onFailure(HttpException e, String s)&quot; + s + &quot;============&quot; + e.toString());
                    e.printStackTrace();
                &#125;
            &#125;);
&#125;
</code></pre>
<p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>微信支付javabean</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********&#x2F;</p>
<pre><code>    package com.***;

    import com.alibaba.fastjson.annotation.JSONField;

    import java.io.Serializable;

    public class WeiXinPayBean implements Serializable &#123;

            private String appId;
            private String partnerid;
            private String prepay_id;
            private String order_id;
            @JSONField(name=&quot;package&quot;)
            private String packageX;
            private String timeStamp;
            private String nonceStr;
            private String return_code;
            private String return_msg;
            private String sign;
            private String err_code_des;

            public String getAppId() &#123;
                return appId;
            &#125;

            public void setAppId(String appId) &#123;
                this.appId = appId;
            &#125;

            public String getPartnerid() &#123;
                return partnerid;
            &#125;

            public void setPartnerid(String partnerid) &#123;
                this.partnerid = partnerid;
            &#125;

            public String getPrepay_id() &#123;
                return prepay_id;
            &#125;

            public void setPrepay_id(String prepay_id) &#123;
                this.prepay_id = prepay_id;
            &#125;

            public void setOrder_id(String order_id) &#123;
                this.order_id = order_id;
            &#125;

            public String getOrder_id() &#123;
                return order_id;
            &#125;

            public String getPackageX() &#123;
                return packageX;
            &#125;

            public void setPackageX(String packageX) &#123;
                this.packageX = packageX;
            &#125;

            public String getTimeStamp() &#123;
                return timeStamp;
            &#125;

            public void setTimeStamp(String timeStamp) &#123;
                this.timeStamp = timeStamp;
            &#125;

            public String getNonceStr() &#123;
                return nonceStr;
            &#125;

            public void setNonceStr(String nonceStr) &#123;
                this.nonceStr = nonceStr;
            &#125;

            public String getReturn_code() &#123;
                return return_code;
            &#125;

            public void setReturn_code(String return_code) &#123;
                this.return_code = return_code;
            &#125;

            public String getReturn_msg() &#123;
                return return_msg;
            &#125;

            public void setReturn_msg(String return_msg) &#123;
                this.return_msg = return_msg;
            &#125;

            public String getSign() &#123;
                return sign;
            &#125;

            public void setSign(String sign) &#123;
                this.sign = sign;
            &#125;

            public String getErr_code_des() &#123;
                return err_code_des;
            &#125;

            public void setErr_code_des(String err_code_des) &#123;
                this.err_code_des = err_code_des;
            &#125;
    &#125;
</code></pre>
<p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>微信支付activity, 必须放在wxapi目录下</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********&#x2F;</p>
<pre><code>    package com.***.wxapi;

    import android.app.Activity;
    import android.content.Context;
    import android.content.Intent;
    import android.os.Bundle;
    import android.support.v4.app.Fragment;
    import android.util.Log;
    import android.widget.Toast;

    import com.syyj.PageUrls;
    import com.syyj.R;
    import com.syyj.WeiXinPayBean;
    import com.syyj.shop.PayFailActivity;
    import com.syyj.shop.PaySuccessActivity;
    import com.tencent.mm.sdk.constants.ConstantsAPI;
    import com.tencent.mm.sdk.modelbase.BaseReq;
    import com.tencent.mm.sdk.modelbase.BaseResp;
    import com.tencent.mm.sdk.modelpay.PayReq;
    import com.tencent.mm.sdk.openapi.IWXAPI;
    import com.tencent.mm.sdk.openapi.IWXAPIEventHandler;
    import com.tencent.mm.sdk.openapi.WXAPIFactory;

    public class WXPayEntryActivity extends Activity implements IWXAPIEventHandler&#123;

        private static final String PAY_SUCCESS_URL = PageUrls.BASE_URL + &quot;/shop/paysuccess/&quot;;
        private static final String PAY_FAIL_URL = PageUrls.BASE_URL + &quot;/shop/payfail/&quot;;

        private WeiXinPayBean weiXinPayBean;

        public static void show(Activity activity, WeiXinPayBean weiXinPayBean, int requestCode) &#123;
            Intent intent = new Intent(activity, WXPayEntryActivity.class);
            intent.putExtra(&quot;weiXinPayBean&quot;, weiXinPayBean);
            activity.startActivityForResult(intent, requestCode);
        &#125;
        public static void show(Fragment fragment, WeiXinPayBean weiXinPayBean, int requestCode) &#123;
            Intent intent = new Intent(fragment.getActivity(), WXPayEntryActivity.class);
            intent.putExtra(&quot;weiXinPayBean&quot;, weiXinPayBean);
            fragment.startActivityForResult(intent, requestCode);
        &#125;

        private static final String TAG = &quot;WXPayEntryActivity&quot;;

        private IWXAPI api;

        @Override
        public void onCreate(Bundle savedInstanceState) &#123;
            super.onCreate(savedInstanceState);
            setContentView(R.layout.pay_result);

            weiXinPayBean = (WeiXinPayBean) getIntent().getSerializableExtra(&quot;weiXinPayBean&quot;);
            api = WXAPIFactory.createWXAPI(getApplicationContext(), weiXinPayBean.getAppId());
            if (weiXinPayBean != null) &#123;
                api = WXAPIFactory.createWXAPI(getApplicationContext(), weiXinPayBean.getAppId());
                pay(this, weiXinPayBean);
            &#125; else &#123;
                api = WXAPIFactory.createWXAPI(getApplicationContext(), weiXinPayBean.getAppId());
                api.handleIntent(getIntent(), this);
            &#125;

        &#125;

        @Override
        protected void onNewIntent(Intent intent) &#123;
            super.onNewIntent(intent);
            setIntent(intent);
            api.handleIntent(intent, this);
        &#125;

        @Override
        public void onReq(BaseReq baseReq) &#123;

        &#125;

        @Override
        public void onResp(BaseResp resp) &#123;
            Log.d(TAG, &quot;WXPayEntryActivity onResp, errCode = &quot; + resp.errCode);

            Log.d(TAG, &quot;WXPayEntryActivity onResp, getType = &quot; + resp.getType());

            Log.d(TAG, &quot;WXPayEntryActivity onResp, COMMAND_PAY_BY_WX = &quot; + ConstantsAPI.COMMAND_PAY_BY_WX);

            if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123;
                // errCode: 0 成功， -1 支付失败， -2 用户取消支付

                if (resp.errCode == 0)  &#123;
                    setResult(RESULT_OK);
                    Toast.makeText(this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show();

                    Intent intent = new Intent(WXPayEntryActivity.this, PaySuccessActivity.class);
                    intent.putExtra(&quot;id&quot;, weiXinPayBean.getOrder_id());
                    startActivity(intent);
    //				WebViewActivity.show(WXPayEntryActivity.this, PAY_SUCCESS_URL+weiXinPayBean.getOrder_id(), &quot;支付成功&quot;, WebViewActivity.FRAGMENT_ORDER_PAY_SUCCESS, true);
                    finish();
                &#125; else &#123;
    //                AlertDialog.Builder builder = new AlertDialog.Builder(this);
    //                builder.setTitle(&quot;支付结果&quot;);
    //                builder.setMessage(String.valueOf(resp.errCode));
    //                builder.show();
    //                setResult(RESULT_CANCELED);
    //				WebViewActivity.show(WXPayEntryActivity.this, PAY_FAIL_URL+weiXinPayBean.getOrder_id(), &quot;支付失败&quot;, WebViewActivity.FRAGMENT_ORDER_PAY_FAIL, true);

                    Intent intent = new Intent(WXPayEntryActivity.this, PayFailActivity.class);
                    intent.putExtra(&quot;id&quot;, weiXinPayBean.getOrder_id());
                    startActivity(intent);
                    finish();
                &#125;
            &#125;
        &#125;


        public void pay(Context context, WeiXinPayBean weiXinPayBean) &#123;
            final IWXAPI msgApi = WXAPIFactory.createWXAPI(context, null);
            // 将该app注册到微信
            msgApi.registerApp(weiXinPayBean.getAppId());

            PayReq request = new PayReq();
            request.appId = weiXinPayBean.getAppId();
            request.partnerId = weiXinPayBean.getPartnerid();
            request.prepayId= weiXinPayBean.getPrepay_id();
            request.packageValue = weiXinPayBean.getPackageX();
            request.nonceStr= weiXinPayBean.getNonceStr();
            request.timeStamp= weiXinPayBean.getTimeStamp();
            request.sign= weiXinPayBean.getSign();
            boolean sendSuccess = msgApi.sendReq(request);
            // 和微信交互可能失败, 失败时直接返回
            if (!sendSuccess) &#123;
                finish();
            &#125;
        &#125;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>[Ruby On Rails] app微信支付配置篇(appid,key,mch_id)</title>
    <url>/2017/03/10/app%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E7%AF%87(appid,key,mch_id)/</url>
    <content><![CDATA[<p>appid:  注册开放平台后，管理中心新建应用审核通过后得到的.</p>
<p>key: 一个32位字符串，在商户平台，api安全中，下载证书的下面有个设置密钥的地方，点击填写两次</p>
<p>mch_id: 注册开放平台后，管理中心应用审核通过，点击查看，申请支付所绑定的商户平台的商户号</p>
]]></content>
      <categories>
        <category>Ruby On Rails</category>
      </categories>
  </entry>
  <entry>
    <title>[RubyOnRails]ckeditor+carrierwave+upyun图片上传</title>
    <url>/2016/10/19/ckeditor+carrierwave+upyun%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>ckeditor+carrierwave+upyun图片上传</p>
<ol>
<li><p>添加gem</p>
<p> gem ‘ckeditor’</p>
</li>
</ol>
<p>参照地址:</p>
<pre><code>https://github.com/galetahub/ckeditor



gem &#39;upyun&#39;

gem &#39;carrierwave&#39;

gem &#39;mini_magick&#39;
</code></pre>
<p>gem “carrierwave-upyun”(NOTE: 此 Gem 是一个 CarrierWave 的组件，你需要配合 CarrierWave 一起使用。</p>
<p>) , 参照地址:</p>
<pre><code>https://github.com/nowa/carrierwave-upyun
</code></pre>
<p>1.新建一个 initializer</p>
<pre><code>config/initializers/carrierwave.rb



# -*- encoding : utf-8 -*-

CarrierWave.configure do |config|

  config.storage = :upyun

  config.upyun_username = Settings.operator

  config.upyun_password = Settings.password

  config.upyun_bucket = Settings.bucket

  config.upyun_bucket_host = &quot;http://images.touring.com.cn&quot;

end
</code></pre>
<ol start="2">
<li><p>生成uploader</p>
<p> rails generate uploader ckeditor_picture</p>
<h1 id="encoding-utf-8"><a href="#encoding-utf-8" class="headerlink" title="-- encoding : utf-8 --"></a>-<em>- encoding : utf-8 -</em>-</h1><p> class CkeditorPictureUploader &lt; CarrierWave::Uploader::Base</p>
<pre><code> include Ckeditor::Backend::CarrierWave

 # Include RMagick or ImageScience support:

 # include CarrierWave::RMagick

 include CarrierWave::MiniMagick

 # include CarrierWave::ImageScience

 CarrierWave::SanitizedFile.sanitize_regexp = /[^[:word:]\.\-\+]/

 # Choose what kind of storage to use for this uploader:

 storage :file

 # Override the directory where uploaded files will be stored.

 # This is a sensible default for uploaders that are meant to be mounted:

 def store_dir

 &quot;uploads/ckeditor/pictures/#&#123;model.id&#125;&quot;

 # &quot;#&#123;model.class.to_s.underscore&#125;/#&#123;mounted_as&#125;&quot;

 end

 # Provide a default URL as a default if there hasn&#39;t been a file uploaded:

 # def default_url

 #   &quot;/images/fallback/&quot; + [version_name, &quot;default.png&quot;].compact.join(&#39;_&#39;)

 # end



 # Process files as they are uploaded:

 # process :scale =&gt; [200, 300]

 #

 # def scale(width, height)

 #   # do something

 # end



 process :read_dimensions



 # Create different versions of your uploaded files:

 # TODO 是不是这里引起的? -- 大师

 version :thumb do

 process :resize_to_fill =&gt; [118, 100]

 end



 version :content do

 process :resize_to_limit =&gt; [800, 800]

 end



 # Add a white list of extensions which are allowed to be uploaded.

 # For images you might use something like this:

 def extension_white_list

 Ckeditor.image_file_types

 end

 def original_filename

 @original_filename

 end

 def filename

 if super.present?

   original = &quot;途铃图片&quot;

   if original_filename.split(&#39;.&#39;).present?

     original = original_filename.split(&#39;.&#39;).first

   end

   Rails.logger.info &quot;== model: #&#123;model.inspect&#125;&quot;

   model.uploader_secure_token ||= SecureRandom.uuid.gsub(&quot;-&quot;,&quot;&quot;)

   Rails.logger.debug(&quot;(BaseUploader.filename) #&#123;model.uploader_secure_token&#125;&quot;)

   &quot;#&#123;original&#125;__#&#123;model.uploader_secure_token&#125;.#&#123;file.extension.downcase&#125;&quot;

 end

 end
</code></pre>
<p> end</p>
</li>
<li><p>修改uploader(这一步很关键)</p>
<p> storage :file 修改为 storage :upyun</p>
</li>
<li><p>生成相应的ActiveRecord</p>
<p> rails generate ckeditor:install –orm&#x3D;active_record –backend&#x3D;carrierwave</p>
</li>
<li><p>Load generated models(加载相应生成的model)</p>
<p> config.autoload_paths +&#x3D; %w(#{config.root}&#x2F;app&#x2F;models&#x2F;ckeditor)</p>
</li>
<li><p>Mount the Ckeditor::Engine in your routes (config&#x2F;routes.rb):(修改route.rb, 路由文件)</p>
<p> mount Ckeditor::Engine &#x3D;&gt; ‘&#x2F;ckeditor’</p>
</li>
<li><p>在application.js 中引用</p>
<p> &#x2F;&#x2F;&#x3D; require ckeditor&#x2F;init</p>
</li>
<li><p>修改 config&#x2F;initializers&#x2F;assets.rb</p>
<p> Rails.application.config.assets.precompile +&#x3D; %w(ckeditor&#x2F;config.js)</p>
</li>
<li><p>在simple_form中的调用</p>
<p> &lt;%&#x3D; f.cktext_area :details %&gt;</p>
</li>
</ol>
<p>10 . Controller 中的写法</p>
<pre><code>bucket = Settings.bucket

operator = Settings.operator

password = Settings.password

air_port_params = params[:air_port]

if air_port_params.present? and air_port_params[:logo].present?

  upload_file = air_port_params[:logo]

  upyun = Upyun::Rest.new(bucket, operator, password)

  new_file_name = Time.now.to_i

  remote_file = &quot;/image/air_port_logo/#&#123;new_file_name&#125;&quot;

  response = upyun.put remote_file, upload_file.read

End
</code></pre>
]]></content>
      <categories>
        <category>RubyOnRails</category>
      </categories>
  </entry>
  <entry>
    <title>[Css]控制禁止输入法</title>
    <url>/2022/07/05/css%E6%8E%A7%E5%88%B6%E7%A6%81%E6%AD%A2%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<p>很简单，一句话</p>
<p>ime-mode:Disabled;</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>[git] 打tag</title>
    <url>/2017/01/20/git%E6%89%93tag/</url>
    <content><![CDATA[<p>标签可以针对某一时间点的版本做标记，常用于版本发布。</p>
<p>列出标签<br>$ Git tag # 在控制台打印出当前仓库的所有标签<br>$ git tag -l ‘v0.1.*’ # 搜索符合模式的标签</p>
<p>打标签<br>git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，附注标签则是仓库中的一个独立对象。建议使用附注标签。</p>
<h1 id="创建轻量标签"><a href="#创建轻量标签" class="headerlink" title="创建轻量标签"></a>创建轻量标签</h1><p>$ git tag v0.1.2-light</p>
<h1 id="创建附注标签"><a href="#创建附注标签" class="headerlink" title="创建附注标签"></a>创建附注标签</h1><p>$ git tag -a v0.1.2 -m “0.1.2版本”</p>
<p>创建轻量标签不需要传递参数，直接指定标签名称即可。<br>创建附注标签时，参数a即annotated的缩写，指定标签类型，后附标签名。参数m指定标签说明，说明信息会保存在标签对象中。</p>
<p>切换到标签<br>与切换分支命令相同，用git checkout [tagname]<br>查看标签信息<br>用git show命令可以查看标签的版本信息：<br>$ git show v0.1.2</p>
<p>删除标签<br>误打或需要修改标签时，需要先将标签删除，再打新标签。<br>$ git tag -d v0.1.2 # 删除标签</p>
<p>参数d即delete的缩写，意为删除其后指定的标签。</p>
<p>给指定的commit打标签<br>打标签不必要在head之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取）。</p>
<h1 id="补打标签"><a href="#补打标签" class="headerlink" title="补打标签"></a>补打标签</h1><p>$ git tag -a v0.1.1 9fbc3d0</p>
<p>标签发布<br>通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作：<br>$ git push origin v0.1.2 # 将v0.1.2标签提交到git服务器<br>$ git push origin –tags # 将本地所有标签一次性提交到git服务器</p>
<p>注意：如果想看之前某个标签状态下的文件，可以这样操作</p>
<p>1.git tag   查看当前分支下的标签</p>
<p>2.git  checkout v0.21   此时会指向打v0.21标签时的代码状态，（但现在处于一个空的分支上）</p>
<ol start="3">
<li>cat  test.txt   查看某个文件</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>[RubyOnRails]gem install mysql2失败解决办法</title>
    <url>/2022/07/05/gem%E5%AE%89%E8%A3%85mysql2%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>gem install mysql2失败解决办法</li>
</ol>
<p>sudo apt-get install libmysqlclient-dev</p>
<p>2.gem install curb失败解决办法</p>
<p>sudo apt-get install libcurl3 libcurl3-gnutls libcurl4-openssl-dev</p>
]]></content>
      <categories>
        <category>RubyOnRails</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>[javascript] highchart使用心得</title>
    <url>/2022/03/11/highchart%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<pre><code>    let that = this;
    Highcharts.setOptions(&#123;
        lang: &#123;
            thousandsSep: &#39;,&#39;
        &#125;
    &#125;);
    let max = 10;
//根据X轴拿到的数据进行判断，没有超过10条就按照X轴拿到的数据总数显示
    if(that.xAxisCategories.length &lt; 10) &#123;
        max = that.xAxisCategories.length -1;
    &#125;
    Highcharts.chart(&#39;chart&#39;, &#123;
        chart: &#123;
            type: &#39;column&#39;
        &#125;,
        scrollbar: &#123;
          enabled: true      //显示滚动条
        &#125;,
        legend: &#123;
            enabled: false   //不现实图例
        &#125;,
        title: &#123;
            text: &#39;&#39;      //不显示标题
        &#125;,
        credits: &#123;
            enabled: false //去掉默认右下角的highchart.com
        &#125;,
        subtitle: &#123;
            text: &#39;&#39; //不现实子标题
        &#125;,
        xAxis: &#123;
            categories: that.xAxisCategories,   //X轴数据，如：[&#39;2022-01-01&#39;, &#39;2022-01-02&#39;, &#39;2022-01-03&#39;, &#39;2022-01-04&#39;, &#39;2022-01-05&#39;, &#39;2022-01-06&#39;, &#39;2022-01-07&#39;]
            tickWidth: 1,    //X轴刻度显示
    //很关键，控制超出多少个会出现滚动条
            min: 0,
            max: max
        &#125;,
        yAxis: &#123;
            title: &#123;
                enabled: false     //Y轴标题是否显示
            &#125;,
            gridLineDashStyle: &#39;longdash&#39;,   //背景显示虚线格
            lineWidth: 1,                   //显示Y轴
            tickWidth: 1,                   //显示Y轴刻度
       //Y轴值为0的时候不居中显示，使用以下两个属性
            min: 0,                       
            minRange: 1
        &#125;,
        plotOptions: &#123;
             //控制显示出来的柱状图样式，颜色等
            column: &#123;
                borderWidth: 0,
                dataLabels: &#123;
                    enabled: true，    //
                    style: &#123;
                        fontWeight: &#39;normal&#39;,
                        color: &#39;#666666&#39;
                    &#125;
                &#125;,
                color: &#39;#45DDCC&#39;
            &#125;
        &#125;,
        series: [&#123;
            name: that.typeText,    //鼠标放在柱状图上，显示的文字
            data: that.seriesData   //Y轴数据，如：[1,2,3,4,5,6,7]
        &#125;]
    &#125;);
</code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>[jQuery]增加 删除 修改select option</title>
    <url>/2013/05/07/jQuery%20%E5%A2%9E%E5%8A%A0%20%E5%88%A0%E9%99%A4%20%E4%BF%AE%E6%94%B9select%20option/</url>
    <content><![CDATA[<p> jQuery获取Select选择的Text和Value:</p>
<pre><code>  1. var checkText=jQuery(&quot;#select_id&quot;).find(&quot;option:selected&quot;).text();   //获取Select选择的Text

  2. var checkValue=jQuery(&quot;#select_id&quot;).val();   //获取Select选择的option Value

  3. var checkIndex=jQuery(&quot;#select_id &quot;).get(0).selectedIndex;   //获取Select选择的索引值

  4. var maxIndex=jQuery(&quot;#select_id option:last&quot;).attr(&quot;index&quot;);   //获取Select最大的索引值
</code></pre>
<p>jQuery添加&#x2F;删除Select的Option项：</p>
<pre><code>  1. jQuery(&quot;#select_id&quot;).append(&quot;
</code></pre>
<p>Text”);   &#x2F;&#x2F;为Select追加一个Option(下拉项)</p>
<pre><code>  2. jQuery(&quot;#select_id&quot;).prepend(&quot;
</code></pre>
<p>请选择”);   &#x2F;&#x2F;为Select插入一个Option(第一个位置)</p>
<pre><code>  3. jQuery(&quot;#select_id option:last&quot;).remove();   //删除Select中索引值最大Option(最后一个)

  4. jQuery(&quot;#select_id option[index=&#39;0&#39;]&quot;).remove();   //删除Select中索引值为0的Option(第一个)

  5. jQuery(&quot;#select_id option[value=&#39;3&#39;]&quot;).remove();   //删除Select中Value=&#39;3&#39;的Option

  6. jQuery(&quot;#select_id option[text=&#39;4&#39;]&quot;).remove();   //删除Select中Text=&#39;4&#39;的Option
</code></pre>
<p>内容</p>
]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
  </entry>
  <entry>
    <title>[jQuery]中removeAttr方法在IE8以下版本中的Bug</title>
    <url>/2022/07/05/jQuery%E4%B8%ADremoveAttr%E6%96%B9%E6%B3%95%E5%9C%A8IE8%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84Bug/</url>
    <content><![CDATA[<p>$(“#inputid”).removeAttr(‘data-validate’)  &#x2F;&#x2F;如果removeAttr不起作用，可以使用</p>
<p>$(“#inputid”).prop(‘data-validate’,false)</p>
<p>或</p>
<p>$(“#inputid”).prop(‘checked’,false) or .removeAttr(‘checked’)?</p>
]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
  </entry>
  <entry>
    <title>javascript - 使用浏览器读取剪切板中的图片内容，并且粘贴到对应的HTML编辑器中</title>
    <url>/2021/08/12/javascript%20-%20%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E5%89%AA%E5%88%87%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E5%86%85%E5%AE%B9%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%B2%98%E8%B4%B4/</url>
    <content><![CDATA[<p>参考：<a href="https://stackoverflow.com/questions/60503912/get-image-using-paste-from-the-browser">https://stackoverflow.com/questions/60503912/get-image-using-paste-from-the-browser</a></p>
<pre><code class="bash">$ // 1. 必须使用 onpaste方法。不能使用 click的方式来调用
document.onpaste = function(pasteEvent) &#123;
  var item = pasteEvent.clipboardData.items[0];

  if (item.type.indexOf(&quot;image&quot;) === 0) &#123;
    var blob = item.getAsFile();

    var reader = new FileReader();

    // 3. 记得要定义好 onload方法
    reader.onload = function(event) &#123;
      // 4. 就可以看到图片的内容了。这个是最最重要的。 
      console.info(&#39;==&#39;,event.target.result)
      // 接下来可以把这个图片的内容通过SDK上传到 CDN服务器上，并且在本地进行回显。 
      $(&#39;#image_preview&#39;).html(&quot;&lt;img src=&quot; + event.target.result +&quot; /&gt;&quot;)
    &#125;;

    // 2. 使用这个方法
    reader.readAsDataURL(blob);
  &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>[JavaScript]设置select为选中</title>
    <url>/2013/03/20/javascript%E8%AE%BE%E7%BD%AEselect%E4%B8%BA%E9%80%89%E4%B8%AD/</url>
    <content><![CDATA[<pre><code>function jsSelectItemByValue(objItemText)
&#123;
    //判断是否存在
    for(var i=0;i
    &#123;
        if(objSelect.options[i].value ==objItemText)
        &#123;
            objSelect.options[i].selected = true;
            break;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>javascript-对于hash进行排序的几种方式</title>
    <url>/2021/09/30/javascript%20-%20%E5%AF%B9%E4%BA%8Ehash%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1-根据-string类型来排序，使用-localeCompare"><a href="#1-根据-string类型来排序，使用-localeCompare" class="headerlink" title="1. 根据 string类型来排序，使用 localeCompare"></a>1. 根据 string类型来排序，使用 localeCompare</h3><pre><code class="bash">$ let elements = [ 
  &#123;   year: 1, value: 1&#125;,   &#123;year: 2, value: 2&#125;
]
elements.filter(x =&gt; x)   // 这个是为了去重复，可以先不看了。
// 为year做排序
.sort( (a,b) =&gt; &#123; return (a.year + &#39;&#39;).localeCompare(b.year + &#39;&#39;)&#125;)
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="2-根据-int类型来排序，使用-号即可"><a href="#2-根据-int类型来排序，使用-号即可" class="headerlink" title="2. 根据 int类型来排序，使用 - 号即可"></a>2. 根据 int类型来排序，使用 - 号即可</h3><pre><code class="bash">$ let elements = [ 
  &#123;   year: 1, value: 1&#125;,   &#123;year: 2, value: 2&#125;
]
// 为year做排序
elements.sort( (a,b) =&gt; &#123; return a.year - b.year&#125;)
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>[php] laravel中使用ckeditor+ckfinder实现图片上传等功能</title>
    <url>/2022/03/19/laravel%E4%B8%AD%E4%BD%BF%E7%94%A8ckeditor+ckfinder%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E7%AD%89%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<pre><code>    ckeditor部分：

    在http://ckeditor.com下载最新版本ckeditor，然后将文件包放在项目根目录下。

    访问以下地址可以测试，是否安装成功：
    http://www.example.com/ckeditor/samples/index.htmlz
    真正实现的项目中可以删掉samples相关。



    ckfinder部分：

    1. composer require ckfinder/ckfinder-laravel-package

    2. php artisan ckfinder:download

    3. php artisan vendor:publish --tag=ckfinder-assets --tag=ckfinder-config

    php artisan vendor:publish --tag=ckfinder-views
    php artisan vendor:publish --tag=ckfinder
    4. 创建上传文件目录，并且修改目录权限：

    mkdir -m 777 public/userfiles
    5. 修改Middleware

    // app/Http/Middleware/EncryptCookies.php

    namespace App\Http\Middleware;

    use Illuminate\Cookie\Middleware\EncryptCookies as Middleware;

    class EncryptCookies extends Middleware
    &#123;
        /**
        * The names of the cookies that should not be encrypted.
        *
        * @var array
        */
        protected $except = [
            &#39;ckCsrfToken&#39;,
            // ...
        ];
    &#125;
    // app/Http/Middleware/VerifyCsrfToken.php

    namespace App\Http\Middleware;

    use Illuminate\Foundation\Http\Middleware\VerifyCsrfToken as Middleware;

    class VerifyCsrfToken extends Middleware
    &#123;
        /**
        * The URIs that should be excluded from CSRF verification.
        *
        * @var array
        */
        protected $except = [
            &#39;ckfinder/*&#39;,
            // ...
        ];
    &#125;
    新建Middleware

    php artisan make:middleware CustomCKFinderAuth
    public function handle(Request $request, Closure $next)
    &#123;
        config([&#39;ckfinder.authentication&#39; =&gt; function() &#123;
            return true;
        &#125;]);
        return $next($request);
    &#125;
    修改`config/ckfinder.php`

    $config[&#39;authentication&#39;] = &#39;\App\Http\Middleware\CustomCKFinderAuth&#39;;
    $config[&#39;csrfProtection&#39;] = false;


    routes/web.php添加下面两个路由

    Route::any(&#39;/ckfinder/connector&#39;, &#39;App\Http\Controllers\CKFinderController@requestAction&#39;)
        -&gt;name(&#39;ckfinder_connector&#39;);

    Route::any(&#39;/ckfinder/browser&#39;, &#39;App\Http\Controllers\CKFinderController@browserAction&#39;)
        -&gt;name(&#39;ckfinder_browser&#39;);
    把vendor/ckfinder/ckfinder-laravel-package/src/Controller/CKFinderController.php， 复制到App/Http/Controllers下，记得修改namespace。

    把vendor/ckfinder/ckfinder-laravel-package/src/CKFinderMiddleware.php

    /复制到App/Http/Middleware下，记得修改namespace。



    记得修改views/ckfinder中browser.blade.php的title等，改成你自己的信息。





    页面调用：

    引入ckeditor， introduction_detail为你的页面textarea的name

    CKEDITOR.replace(&#39;introduction_detail&#39;, &#123;
        language: &#39;ja&#39;,  //语言设置
        filebrowserBrowseUrl: &quot;&#123;&#123;route('ckfinder_browser')&#125;&#125;&quot;,
        filebrowserUploadUrl: &quot;&#123;&#123;route('ckfinder_connector')&#125;&#125;?command=QuickUpload&amp;type=Files&quot;  //参数不能去掉哦
    &#125;);


    ckfinder在views/setup.blade.php中有引用，所以这里不需要再次引用了。
</code></pre>
]]></content>
      <categories>
        <category>laravel ckeditor ckfinder</category>
      </categories>
  </entry>
  <entry>
    <title>[Ubuntu]linux下vim命令详解</title>
    <url>/2013/05/07/linux%E4%B8%8Bvim%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>高级一些的编辑器，都会包含宏功能，vim当然不能缺少了，在vim中使用宏是非常方便的：</p>
<p>:qx     开始记录宏，并将结果存入寄存器x</p>
<p>q     退出记录模式</p>
<p>@x     播放记录在x寄存器中的宏命令</p>
<p>稍微解释一下，当在normal模式下输入:qx后，你对文本的所有编辑动作将会被记录下来，再次输入q即退出了记录模<br>式，然后输入@x对刚才记录下来的命令进行重复，此命令后可跟数字，表示要重复多少次，比如@x20，可以重复20次。这个在文本的批处理中是非常有用的。<br>同时编辑多个文件<br>在vim众多的插件中，有一个叫minibuffer的插件，就是下面所说的标签页功能了，可以支持同时编辑多个文件。</p>
<p>标签命令</p>
<p>:tabe fn     在一个新的标签页中编辑文件fn<br>gt     切换到下一个标签页<br>gT     切换到上一个标签页<br>:tabr     切换到第一个标签页<br>:tabl     切换到最后一个标签页<br>:tabm [N]     把当前tab移动到第N个tab之后<br>对，正如你所想象的那样，跟eclipse, ue等的标签页是一个意思！<br>窗口命令<br>ctrl+w s     水平分割窗口<br>ctrl+w w     切换窗口<br>ctrl+w q     退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)<br>ctrl+w v     垂直分割窗口</p>
<p>其他<br>vim在保存之前不会对文件做实际的修改，只是加载到缓冲区中，对文件的编辑其实是对缓冲区的编辑，直到:w时才会存入物理文件。</p>
<p>:e file     把file加载到新的缓冲区中<br>:bn     跳转到下一个缓冲区<br>:bd     删除缓冲区(关闭文件)<br>:sp fn     分割窗口，并将fn加载到新的窗口中</p>
<p>退出编辑器</p>
<p>:w     将缓冲区写入文件，即保存修改<br>:wq     保存修改并退出<br>:x     保存修改并退出<br>:q     退出，如果对缓冲区进行过修改，则会提示<br>:q!     强制退出，放弃修改</p>
<p>查找替换<br>&#x2F;pattern     向后搜索字符串pattern<br>?pattern     向前搜索字符串pattern<br>n     下一个匹配(如果是&#x2F;搜索，则是向下的下一个，?搜索则是向上的下一个)<br>N     上一个匹配(同上)<br>:%s&#x2F;old&#x2F;new&#x2F;g     搜索整个文件，将所有的old替换为new<br>:%s&#x2F;old&#x2F;new&#x2F;gc     搜索整个文件，将所有的old替换为new，每次都要你确认是否替换</p>
<p>复制粘贴<br>dd     删除光标所在行<br>dw     删除一个字(word)<br>x     删除当前字符<br>X     删除前一个字符<br>D     删除到行末<br>yy     复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行<br>yw     复制一个字<br>y$     复制到行末<br>p     粘贴粘贴板的内容到当前行的下面<br>P     粘贴粘贴板的内容到当前行的上面<br>]p     有缩进的粘贴，vim会自动调节代码的缩进<br>“a     将内容放入&#x2F;存入a寄存器，可以支持多粘贴板<br>附：比如常用的一个寄存器就是系统寄存器，名称为+，所以从系统粘贴板粘贴到vim中的命令为”+p,注意此处的+不表示操作符，二十一个寄存器。<br>移动光标<br>在vim中移动光标跟其他的编辑器中有很大的区别，不过一旦学会了，就会飞速的在文本中移动了。</p>
<p>h,j,k,l     上，下，左，右<br>ctrl-f     上翻一页<br>ctrl-b     下翻一页<br>%     跳到与当前括号匹配的括号处，如当前在{，则跳转到与之匹配的}处<br>w     跳到下一个字首，按标点或单词分割<br>W     跳到下一个字首，长跳，如end-of-line被认为是一个字<br>e     跳到下一个字尾<br>E     跳到下一个字尾，长跳<br>b     跳到上一个字<br>B     跳到上一个字，长跳<br>0     跳至行首，不管有无缩进，就是跳到第0个字符<br>^     跳至行首的第一个字符<br>$     跳至行尾<br>gg     跳至文件的第一行<br>gd     跳至当前光标所在的变量的声明处<br>[N]G     跳到第N行，如0G，就等价于gg，100G就是第100行<br>fx     在当前行中找x字符，找到了就跳转至<br>;     重复上一个f命令，而不用重复的输入fx<br>tx     与fx类似，但是只是跳转到x的前一个字符处<br>Fx     跟fx的方向相反<br>),(     跳转到上&#x2F;下一个语句</p>
<ul>
<li><pre><code>查找光标所在处的单词，向下查找
</code></pre>
</li>
</ul>
<h1 id="查找光标所在处的单词，向上查找"><a href="#查找光标所在处的单词，向上查找" class="headerlink" title="查找光标所在处的单词，向上查找"></a>查找光标所在处的单词，向上查找</h1><p>&#96;.     跳转至上次编辑位置</p>
<p>在屏幕上移动</p>
<p>H     移动光标到当前屏幕上最上边的一行<br>M     移动光标到当前屏幕上中间的一行<br>L     移动光标到当前屏幕上最下边的一行<br>书签<br>ma     把当前位置存成标签a<br>&#96;a     跳转到标签a处</p>
<p>编辑<br>r     替换一个字符<br>J     将下一行和当前行连接为一行<br>cc     删除当前行并进入编辑模式<br>cw     删除当前字，并进入编辑模式<br>c$     擦除从当前位置至行末的内容，并进入编辑模式<br>s     删除当前字符并进入编辑模式<br>S     删除光标所在行并进入编辑模式<br>xp     交换当前字符和下一个字符<br>u     撤销<br>ctrl+r   重复上一个编辑命令<br>~     切换大小写，当前字符<br>g~iw     切换当前字的大小写<br>gUiw     将当前字变成大写<br>guiw     将当前字变成小写</p>
<blockquote>
<blockquote>
<pre><code>将当前行右移一个单位
</code></pre>
<p>&lt;&lt;     将当前行左移一个单位(一个tab符)<br>&#x3D;&#x3D;     自动缩进当前行</p>
</blockquote>
</blockquote>
<p>插入模式<br>i     从当前光标处进入插入模式<br>I     进入插入模式，并置光标于行首<br>a     追加模式，置光标于当前光标之后<br>A     追加模式，置光标于行末<br>o     在当前行之下新加一行，并进入插入模式<br>O     在当前行之上新加一行，并进入插入模式<br>Esc     退出插入模式</p>
<p>可视模式<br>标记文本<br>v     进入可视模式，单字符模式<br>V     进入可视模式，行模式<br>ctrl+v     进入可视模式，列模式，类似于UE的列模式<br>o     跳转光标到选中块的另一个端点<br>U     将选中块中的内容转成大写<br>O     跳转光标到块的另一个端点<br>aw     选中一个字<br>ab     选中括号中的所有内容，包括括号本身<br>aB     选中{}括号中的所有内容<br>ib     选中括号中的内容，不含括号<br>iB     选中{}中的内容，不含{}</p>
<p>对标记进行动作</p>
<blockquote>
<pre><code>块右移
</code></pre>
<p>&lt;     块左移<br>y     复制块<br>d     删除块<br>~     切换块中内容的大小写</p>
</blockquote>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>[Php]错误信息的显示</title>
    <url>/2015/05/14/php%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>修改php.ini(&#x2F;etc&#x2F;php5&#x2F;apache2&#x2F;)</p>
<p>display_errors &#x3D; On</p>
<p>error_reporting &#x3D; E_ALL &amp; ~E_NOTICE</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>[rails] 项目增加日志功能(log)</title>
    <url>/2017/01/10/rails%20%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%8A%A0%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD(log)/</url>
    <content><![CDATA[<p>操作日志是几乎每一个项目所必须要有的</p>
<p>我本来希望把它做成一个rails plugin 或者gem, 但是时间有限…</p>
<p>下面是rails中的增加步骤:</p>
<ol>
<li>Gemfile中<br>gem ‘kaminari’</li>
<li>config&#x2F;routes.rb<br>  namespace “monitor” do<br> resources “logs”<br>  end </li>
<li>app&#x2F;controllers&#x2F;monitor&#x2F;logs_controller.rb :<br>class Monitor::LogsController &lt; ApplicationController<br>  def index<br> @logs &#x3D; OperationLog.order(‘created_at desc’).page(params[:page]).per(100)<br>  end<br>end</li>
<li>app&#x2F;views&#x2F;monitor&#x2F;logs&#x2F;index.hml.erb:<h3>操作日志</h3>
<%= paginate @logs %> 
<table >
  <tr>
 <th>controller</th>
 <th>action</th>
 <th>时间</th>
 <th>用户名</th>
 <th>详情</th>
  </tr>
  <% @logs.each do |log| %>
  <tr>
 <td><%= log.controller %></td>
 <td><%= log.action %></td>
 <td><%= log.created_at.strftime '%y-%m-%d %H:%M:%S' %></td>
 <td><%= log.user_name %></td>
 <td><%= log.params %></td>
  </tr>
  <% end %></li>
</ol>
</table>
<%= paginate @logs %>

<ol start="5">
<li>lib&#x2F;loggable_controller:</li>
</ol>
<p>module LoggableController<br>  def save_log<br>    controller &#x3D; params[:controller]<br>    action &#x3D; params[:action]<br>    request_type &#x3D; restful_method(params)<br>    OperationLog.create!(:action &#x3D;&gt; action, :controller &#x3D;&gt; controller,<br>        :user_name &#x3D;&gt; current_user.try(:email),<br>        :parameters &#x3D;&gt;  params.inspect,<br>        :remote_ip&#x3D;&gt; request.remote_ip,<br>        :restful_method &#x3D;&gt; restful_method(params)<br>    )<br>  end </p>
<p>  private</p>
<h1 id="return-get-post-put-or-delete"><a href="#return-get-post-put-or-delete" class="headerlink" title="return: get, post, put or delete"></a>return: get, post, put or delete</h1><p>  def restful_method(params)<br>    return request.method.downcase<br>    #params[:authenticity_token].blank? ? ‘get’ : ((params[:_method]) || ‘post’)<br>  end<br>end<br>6. 然后,在 app&#x2F;controller&#x2F;application_controller 中: </p>
<p>class ApplicationController &lt; ActionController::Base<br>  include LoggableController<br>  before_filter :save_log<br>end<br>7. 在 config&#x2F;initializers&#x2F;loggable_controller.rb中:<br>Dir[Rails.root + ‘lib&#x2F;loggable_controller.rb’].each do |file|<br>  require file<br>end</p>
<p>8 . 创建 logs表:</p>
<p>class CreateLogs &lt; ActiveRecord::Migration<br>  def change<br>    create_table :logs do |t|<br>      t.string :controller<br>      t.string :action<br>      t.string :user_name<br>      t.text :parameters<br>      t.datetime :created_at<br>    end<br>  end<br>end</p>
<ol start="9">
<li>创建 app&#x2F;models&#x2F;log.rb</li>
</ol>
<h1 id="encoding-utf-8"><a href="#encoding-utf-8" class="headerlink" title="-- encoding : utf-8 --"></a>-<em>- encoding : utf-8 -</em>-</h1><p>class Log &lt; ActiveRecord::Base<br>end<br>10. 创建 migration $ bundle exec rails g migration create_operation_logs</p>
<p>class CreasteOperationLogs &lt; ActiveRecord::Migration<br>  def change<br>    create_table :operation_logs, :comment &#x3D;&gt; ‘操作日志表’ do |t|<br>      t.string :controller<br>      t.string :action<br>      t.string :remote_ip, :comment &#x3D;&gt; ‘远程ip’<br>      t.string :restful_method, :comment &#x3D;&gt; ‘请求的方法,  get&#x2F;post…’<br>      t.string :user_name, :comment &#x3D;&gt; ‘当前用户’<br>      t.text :parameters, :comment &#x3D;&gt; ‘各种参数’<br>      t.datetime :created_at, :comment &#x3D;&gt; ‘创建时间’<br>    end<br>  end<br>end</p>
]]></content>
      <categories>
        <category>rails</category>
      </categories>
  </entry>
  <entry>
    <title>[RubyOnRails]常用正则表达式</title>
    <url>/2013/05/07/ruby%20on%20rails%20%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<pre><code>#1.用戶名注冊
/^[a-z0-9_-]&#123;3,16&#125;$/
#以字母開頭,包含字母,數字,_,-的3-16個字符

#2.用戶密碼
/^[a-z0-9_-]&#123;6,18&#125;$/
#同上

#3.十六進制數
/^#?([a-f0-9]&#123;6&#125;|[a-f0-9]&#123;3&#125;)$/
#以#开头或者不以#开头, 后面跟 6个字符(a-f或者0-9) 或者 3个字符(a-f或者0-9)

#4.匹配一個Slug(啥叫Slug?看看上面地址栏里的那一陀)
/^[a-z0-9-]+$/
#多個字母(a-z),數字(0-9),和-組成的字符

#5.匹配Email地址,此乃神器也
/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)$/

#6.匹配Url
/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/

#7.匹配IP地址
num = /\d|[01]?\d\d|2[0-4]\d|25[0-5]/
exp = /^(#&#123;num&#125;\.)&#123;3&#125;#&#123;num&#125;$/

#num是每个数字串的匹配模式, exp就是最终的RegExp了,下面是演示:

irb(main):001:0&gt; num = /\d|[01]?\d\d|2[0-4]\d|25[0-5]/
=&gt; /\d|[01]?\d\d|2[0-4]\d|25[0-5]/
irb(main):002:0&gt; exp = /^(#&#123;num&#125;\.)&#123;3&#125;#&#123;num&#125;$/
=&gt; /^((?-mix:\d|[01]?\d\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;(?-mix:\d|[01]?\d\d|2[0-4]\d|25[0-5])$/
irb(main):003:0&gt; exp.match(&quot;192.168.1.22&quot;)
=&gt; #&lt;MatchData &quot;192.168.1.22&quot; 1:&quot;1.&quot;&gt;

#8.匹配时间/日期类型（yyyy.mm.dd hh:mm:ss)
yyyy = /[1-9]\d\d\d/
mm = /0?[1-9]|1[12]/
dd = /0?[1-9]|[12]\d|3[01]/
hh = /[01]?[1-9]|2[0-4]/
MM = /[0-5]\d/
ss = /[0-5]\d/
date_time = /^(#&#123;yyyy&#125;\.#&#123;mm&#125;\.#&#123;dd&#125;) (#&#123;hh&#125;:#&#123;MM&#125;:#&#123;ss&#125;)$/
</code></pre>
<p>   #9.只能是数字或者小数</p>
<pre><code>with_options :format =&gt; &#123;:with =&gt; /^[1-9][0-9]&#123;0,2&#125;(?:,?[0-9]&#123;3&#125;)*(?:\.[0-9]&#123;1,2&#125;)?$/, :message =&gt; &quot;格式错误，只能是数字或者小数&quot;&#125;,:allow_blank=&gt;true do |v|
  v.validates :realOperationsKm
  v.validates :realTravelKm
  v.validates :addOil
  v.validates :addOilBycash
  v.validates :extraHourQty
  v.validates :realExtraHourFee
  v.validates :realXKm
  v.validates :realXKmFee
  v.validates :roadBridgeFee
  v.validates :realParkingCharge
  v.validates :othercharge
end
</code></pre>
<p>   #10.车牌号正则<br>   &#x2F;^[\u4e00-\u9fa5]{1}[A-Z]{1}-[A-Z_0-9]{5}$&#x2F;<br>validates :car_tag,:engine_type, :format&#x3D;&gt;{:with&#x3D;&gt;&#x2F;^[\u4e00-\u9fa5]{1}[A-Z]{1}-[A-Z_0-9]{5}$&#x2F;,:message&#x3D;&gt;”车牌号格式不正确”}</p>
<p>   #11.手机号码<br>   &#x2F;^1[3|4|5|8][0-9]\d{4,8}$&#x2F;</p>
<p>   #12.传真&#x2F;电话号码<br>   &#x2F;^((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)&#x2F;</p>
]]></content>
      <categories>
        <category>RubyOnRails</category>
      </categories>
  </entry>
  <entry>
    <title>[RubyOnRails]rvm is not a function的解决方法</title>
    <url>/2022/07/05/rvm%20is%20not%20a%20function%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/fantiantian/p/3392357.html">http://www.cnblogs.com/fantiantian/p/3392357.html</a></p>
<p>执行如下命令：</p>
<p>&#x2F;bin&#x2F;bash –login</p>
<p>（设置terminal[终端],以登录shell方式运行命令[Run command as a login shell 的选项, 把它选上]）</p>
]]></content>
      <categories>
        <category>RubyOnRails</category>
      </categories>
  </entry>
  <entry>
    <title>[Ubuntu]安装jdk</title>
    <url>/2022/07/05/ubuntu%20%E5%AE%89%E8%A3%85%20JDK/</url>
    <content><![CDATA[<p>具体步骤参详了如下链接：<br><a href="http://blog.csdn.net/yang_hui1986527/article/details/6677450">http://blog.csdn.net/yang_hui1986527&#x2F;article&#x2F;details&#x2F;6677450</a></p>
<p>1、到 Sun 的官网下载</p>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html</a><br>选择 accept license ，然后选择适合自己机型的JDK下载。</p>
<p>2、解压文件，修改文件名</p>
<p>$ sudo mkdir &#x2F;usr&#x2F;lib&#x2F;jvm<br>$ sudo tar zxvf jdk-7u21-linux-i586.tar.gz -C &#x2F;usr&#x2F;lib&#x2F;jvm<br>$ cd &#x2F;usr&#x2F;lib&#x2F;jvm<br>$ sudo mv jdk1.7.0_21 java</p>
<p>3、添加环境变量</p>
<p>$ sudo vim ~&#x2F;.bashrc<br>加入如下内容<br>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java<br>export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre<br>export CLASSPATH&#x3D;.:${JAVA_HOME}&#x2F;lib:${JRE_HOME}&#x2F;lib<br>export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH</p>
<p>4、配置默认JDK版本</p>
<p>sudo update-alternatives –install &#x2F;usr&#x2F;bin&#x2F;java java &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java&#x2F;bin&#x2F;java 300<br>sudo update-alternatives –install &#x2F;usr&#x2F;bin&#x2F;javac javac &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java&#x2F;bin&#x2F;javac 300<br>sudo update-alternatives –install &#x2F;usr&#x2F;bin&#x2F;jar jar &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java&#x2F;bin&#x2F;jar 300<br>sudo update-alternatives –install &#x2F;usr&#x2F;bin&#x2F;javah javah &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java&#x2F;bin&#x2F;javah 300<br>sudo update-alternatives –install &#x2F;usr&#x2F;bin&#x2F;javap javap &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java&#x2F;bin&#x2F;javap 300<br>然后执行<br>sudo update-alternatives –config java<br>若是初次安装 JDK， 将提示<br>There is only one alternative in link group java (providing &#x2F;usr&#x2F;bin&#x2F;java): &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java&#x2F;bin&#x2F;java<br>无需配置。<br>若是非初次安装，将有不同版本的 JDK 选项。</p>
<p>5、测试</p>
<p>$ java -version<br>java version “1.7.0_21” Java(TM) SE Runtime Environment (build 1.7.0_21-b11)<br>Java HotSpot(TM) Server VM (build 23.21-b01, mixed mode)</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>[MySql]Ubuntu下安装MYSQL</title>
    <url>/2013/05/07/ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85MySQL/</url>
    <content><![CDATA[<p>　　1. sudo apt-get install mysql-server</p>
<p>　　2. sudo apt-get install mysql-client</p>
<p>　　3. sudo apt-get install libmysqlclient-dev</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>[Android]ubuntu下adb连接android手机</title>
    <url>/2016/11/17/ubuntu%E4%B8%8Badb%E8%BF%9E%E6%8E%A5android%E6%89%8B%E6%9C%BA/</url>
    <content><![CDATA[<p>ubuntu下adb连接android手机</p>
<ol>
<li><p>sudo apt install android-tools-adb</p>
</li>
<li><p>设置usb选项， 媒体设备(MTP)</p>
</li>
<li><p>查看手机的usb信息    lsusb</p>
</li>
</ol>
<p>Bus 002 Device 004: ID 18c3:6255</p>
<p>Bus 002 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub</p>
<p>Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</p>
<p>Bus 001 Device 005: ID 22b8:41db Motorola PCS Motorola Droid (USB Debug)</p>
<p>Bus 001 Device 004: ID 04d9:a06b Holtek Semiconductor, Inc.</p>
<p>Bus 001 Device 003: ID 058f:b002 Alcor Micro Corp.</p>
<p>Bus 001 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub</p>
<ol start="4">
<li>添加udev规则</li>
</ol>
<p>cd &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;</p>
<p>sudo vim 50-android-usb.rules</p>
<p>编辑规则文件并保存</p>
<p> SUBSYSTEM&#x3D;&#x3D;”usb”, SYSFS(“Motorola PCS Motorola Droid (USB Debug)”)&#x3D;&#x3D;”22b8”,MODE&#x3D;”0666”</p>
<p> 其中，sysfs括号内是自己android手机的实际描述信息，&#x3D;&#x3D;后面的是id号，mode是读取模式，0666是所有人可以访问，以上的信息都是lsusb查处来的。</p>
<ol start="5">
<li>设置规则文件权限以及重启</li>
</ol>
<p>sudo chmod a+rx &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;50-android-usb.rules</p>
<p>sudo &#x2F;etc&#x2F;init.d&#x2F;udev restart</p>
<ol start="6">
<li>设置adb信息</li>
</ol>
<p> 进入sdk得platform-tools目录</p>
<p>hang@CAPF:&#x2F;opt&#x2F;android-sdk-linux_x86&#x2F;platform-tools$ sudo .&#x2F;adb kill-server</p>
<p>hang@CAPF:&#x2F;opt&#x2F;android-sdk-linux_x86&#x2F;platform-tools$ sudo .&#x2F;adb devices</p>
<ul>
<li><p>daemon not running. starting it now on port 5037 *</p>
</li>
<li><p>daemon started successfully *</p>
</li>
</ul>
<p>List of devices attached</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>[Ubuntu]Ubuntu手动设置HOSTS</title>
    <url>/2015/05/15/ubuntu%E4%B8%8B%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AEHOSTS/</url>
    <content><![CDATA[<p>sudo gedit &#x2F;etc&#x2F;hosts</p>
<p>示例: 61.135.169.125 <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>编辑后，你使用如下命令需要重新启动一下你的网络：</p>
<p>sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>[Ubuntu]使用google拼音输入法</title>
    <url>/2013/03/26/ubuntu%E4%BD%BF%E7%94%A8google%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<p> linux下面的中文输入法一直不给力</p>
<p>现在，google拼音输入法可以用了！这得感谢下面这个项目：<br>libgooglepinyin ( A fork from google pinyin on android)<br>项目地址：<a href="http://code.google.com/p/libgooglepinyin/">http://code.google.com/p/libgooglepinyin/</a></p>
<p>准备工作：你得安装ibus。（这是ubuntu的默认输入法框架，所以一般都不需要你去安装），具体可以参考 <a href="http://wiki.ubuntu.org.cn/IBus">http://wiki.ubuntu.org.cn/IBus</a></p>
<p>然后：<br>sudo apt-get install cmake build-essential opencc mercurial ibus</p>
<p>hg clone <a href="http://code.google.com/p/libgooglepinyin/">http://code.google.com/p/libgooglepinyin/</a></p>
<p>cd libgooglepinyin</p>
<p>mkdir build;</p>
<p>cd build</p>
<p>cmake .. -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr</p>
<p>make</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>[vue] vue(h5)+ror加入popup-picker实现省市县级联</title>
    <url>/2017/02/20/vue(h5)+ror%E5%8A%A0%E5%85%A5popup-picker%E5%AE%9E%E7%8E%B0%E7%9C%81%E5%B8%82%E5%8E%BF%E7%BA%A7%E8%81%94/</url>
    <content><![CDATA[<p>项目中导入:</p>
<pre><code>import Picker from &#39;../picker&#39;

import Cell from &#39;../cell&#39;

import Popup from &#39;../popup&#39;

import InlineDesc from &#39;../inline-desc&#39;

import &#123; Flexbox, FlexboxItem &#125; from &#39;../flexbox&#39;

import array2string from &#39;../../filters/array2String&#39;

import value2name from &#39;../../filters/value2name&#39;

import uuidMixin from &#39;../../libs/mixin_uuid
</code></pre>
<p>每个都需要导入，不能缺少。</p>
<p>ror部分: </p>
<pre><code>def get_data
    @data = []
        Province.includes(:cities).each do |province|
            @data.push(&#123;
                       name: province.name,
                       value: province.name,
                       parent: 0
            &#125;)
                    province.cities.includes(:towns).each do |city|
                        @data.push(&#123;
                                     name: city.name,
                                     value: city.name,
                                     parent: province.name
                        &#125;)
                        city.towns.each do |town|
                            @data.push(&#123;
                                       name: town.name,
                                       value: town.name,
                                       parent: city.name
                            &#125;)
                        end
                  end
            end
      	@data
end
</code></pre>
<p>vue(h5)部分：</p>
<pre><code>&lt;group&gt;
   &lt;popup-picker :title=&quot;title&quot; :data=&quot;data&quot; :columns=&quot;3&quot; v-model=&quot;address_array&quot; ref=&quot;picker3&quot; stlye=&quot;font-size: 20px;&quot;&gt;&lt;/popup-picker&gt;
&lt;/group&gt;
</code></pre>
<p>这里的data即为get_data的结果。address_array是当前所选中的省市县(如: [‘陕西’, ‘西安’， ‘新城区’])</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vuejs - 普通方法 ， watch 与 computed</title>
    <url>/2021/07/15/vuejs%20-%20methods%EF%BC%8C%20watch%20%E4%B8%8E%20computed/</url>
    <content><![CDATA[<h2 id="例子参考"><a href="#例子参考" class="headerlink" title="例子参考"></a>例子参考</h2><p><a href="https://cn.vuejs.org/v2/guide/computed.html">https://cn.vuejs.org/v2/guide/computed.html</a></p>
<p>一些时候，computed  也可以使用 methods 来实现。区别是</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>有缓存。 提供了getter, 但是也提供了setter</p>
<p>computed中的属性跟data中定义的变量是同等地位的（也就是说， computed中定义了，data中就不用出现了。都可以使用this.xx 来访问）</p>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>： 没有缓存， 每次都计算</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>可以使用watch来实现computed, 使用 异步操作时，把结果使用watch 来监听是合适的（只能由watch来实现，computed无法实现）<br>所有watch的变量都是data中定义的变量</p>
]]></content>
  </entry>
  <entry>
    <title>[Vue]vuejs中获取各个国家的假期时间</title>
    <url>/2022/07/10/vuejs%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%81%87%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h3 id="使用yarn或者npm安装包"><a href="#使用yarn或者npm安装包" class="headerlink" title="使用yarn或者npm安装包"></a>使用yarn或者npm安装包</h3><pre><code class="bash">yarn add date-holidays
or
npm install date-holidays
</code></pre>
<blockquote>
<p>这块注意自己的node版本，不同node版本匹配不同版本的包</p>
</blockquote>
<h3 id="在-vue中的使用"><a href="#在-vue中的使用" class="headerlink" title="在.vue中的使用"></a>在.vue中的使用</h3><pre><code class="bash">import Holidays from &quot;date-holidays&quot;;
// JP指取日本的数据: (具体国家代码缩写后面有说明)
let holidays = new Holidays(&#39;JP&#39;)

//下面是比较常用的方法
//获取指定年的假期数据信息, year为指定年份
holidays.getHolidays(year)

//判断指定日期是否为假期, date为需要判断的日期字符串
holidays.isHoliday(date)   //该方法返回结果为false即不是假期，如果是一个对象即相应的假期信息
</code></pre>
<p><sub>具体国家代码缩写，以及相应版本请参考</sub><br><a href="https://yarnpkg.com/package/date-holidays">Click this</a>.</p>
<blockquote>
<p>非常方便，有使用到类似功能开发的，推荐使用.</p>
</blockquote>
<blockquote>
<p>我这边是后端的数据需要进行判断和比对，所以这块是前端调用<code>getHolidays</code>方法获取假期数据，传递到后台，后台处理，前端再显示。</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>[RubyOnRails]一些网址</title>
    <url>/2013/03/18/%E4%B8%80%E4%BA%9B%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<p><a href="http://js2coffee.thomaskalka.de/">http://js2coffee.thomaskalka.de/</a>              javascript和coffeescript在线转换</p>
<p><a href="http://slim-lang.com/">http://slim-lang.com/</a>                                 slim template官方首页</p>
<p><a href="http://coffeescript.org/">http://coffeescript.org/</a>                               coffeescript官方首页</p>
]]></content>
      <categories>
        <category>RubyOnRails</category>
      </categories>
  </entry>
  <entry>
    <title>[php] 如何使用workman为laravel项目添加websocket在线聊天沟通？.markdown</title>
    <url>/2022/06/08/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8workman%E4%B8%BAlaravel%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0websocket%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E6%B2%9F%E9%80%9A%EF%BC%9F/</url>
    <content><![CDATA[<pre><code>        第一步，

        composer require workerman/gateway-worker



        第二步，

        创建commond

        php artisan make:commond WorkermanCommand

        具体内容如下：

        &lt;?php
        namespace App\Console\Commands;
        use App\Workerman\Events;
        use GatewayWorker\BusinessWorker;
        use GatewayWorker\Gateway;
        use GatewayWorker\Register;
        use Illuminate\Console\Command;
        use Workerman\Worker;
        class WorkermanCommand extends Command
        &#123;
            protected $signature = &#39;workman &#123;action&#125; &#123;--d&#125;&#39;;
            protected $description = &#39;Start a Workerman server.&#39;;
            public function handle()
            &#123;
                global $argv;
                $action = $this-&gt;argument(&#39;action&#39;);
                $argv[0] = &#39;wk&#39;;
                $argv[1] = $action;
                $argv[2] = $this-&gt;option(&#39;d&#39;) ? &#39;-d&#39; : &#39;&#39;;
                $this-&gt;start();
            &#125;
            private function start()
            &#123;
                $this-&gt;startGateWay();
                $this-&gt;startBusinessWorker();
                $this-&gt;startRegister();
                Worker::runAll();
            &#125;
            private function startBusinessWorker()
            &#123;
                $worker                  = new BusinessWorker();
                //work名称
                $worker-&gt;name            = &#39;BusinessWorker&#39;;
                //businessWork进程数
                $worker-&gt;count           = 2;
                //服务注册地址 0.0.0.0
                $worker-&gt;registerAddress = config(&#39;websocket.register_address&#39;).&#39;:1236&#39;;
                //设置\App\Workerman\Events类来处理业务
                $worker-&gt;eventHandler    = Events::class;
            &#125;
            private function startGateWay()
            &#123;
                //gateway进程
                $gateway = new Gateway(&quot;websocket://0.0.0.0:2346&quot;);
                //gateway名称 status方便查看
                $gateway-&gt;name                 = &#39;Gateway&#39;;
                //gateway进程
                $gateway-&gt;count                = 2;
                //本机ip 0.0.0.0
                $gateway-&gt;lanIp                = config(&#39;websocket.lan_ip&#39;);
                //内部通讯起始端口，如果$gateway-&gt;count = 4 起始端口为2300
                //则一般会使用 2300，2301 2个端口作为内部通讯端口
                $gateway-&gt;startPort            = 2300;
                //心跳间隔
                $gateway-&gt;pingInterval         = 30;
                //客户端连续$pingNotResponseLimit次$pingInterval时间内不发送任何数据则断开链接，并触发onClose。
                //我们这里使用的是服务端主动发送心跳所以设置为0
                $gateway-&gt;pingNotResponseLimit = 0;
                //心跳数据
                $gateway-&gt;pingData             = &#39;&#123;&quot;type&quot;:&quot;@heart@&quot;&#125;&#39;;
                //服务注册地址
                $gateway-&gt;registerAddress      = config(&#39;websocket.register_address&#39;).&#39;:1236&#39;;
            &#125;
            private function startRegister()
            &#123;
                new Register(&#39;text://0.0.0.0:1236&#39;);
            &#125;
        &#125;

        第三步，

        创建Event.php

        具体代码如下：

        &lt;?php

        namespace App\Workerman;

        use App\Models\User;
        use App\Services\ChartService;
        use GatewayWorker\Lib\Gateway;
        use Illuminate\Support\Facades\Cache;
        use Illuminate\Support\Facades\Log;

        class Events
        &#123;
            // businessWorker进程启动事件
            public static function onWorkerStart($businessWorker)
            &#123;
                echo &quot;BusinessWorker    Start\n&quot;;
            &#125;
            /**
            * 当客户端连接时触发
            * 如果业务不需此回调可以删除onConnect
            *
            * @param int $client_id 连接id
            */
            public static function onConnect($clientId)
            &#123;
                Log::info(&#39;socket_message:客户端连接上gateway进程&#39;);
                Log::info(&#39;客户端连接时的$clientId==&#39; . $clientId);
            &#125;
            // 当客户端连接上来时，设置连接的onWebSocketConnect，即在websocket握手时的回调
            public static function onWebSocketConnect($clientId)
            &#123;
                Log::info(&#39;socket_message:客户端连接上gateway完成websocket握手&#39;);
                Log::info(&#39;握手的$clientId==&#39; . $clientId);
            &#125;

            public static function setClientId($token, $clientId)
            &#123;
                $sendUserClientId = Cache::get($token);
                if (empty($sendUserClientId)) &#123;
                    Cache::put($token, $clientId);
                &#125; else &#123;
                    if ($sendUserClientId != $clientId) &#123;
                        Cache::put($token, $clientId);
                    &#125;
                &#125;
            &#125;

            public static function updateUserMessageToken($userId, $token)
            &#123;
                //user表更新消息token
            &#125;

            public static function getUserClientId($userId)
            &#123;
                //根据user信息，从缓存中取得clientId
                return Cache::get($user-&gt;message_token);
            &#125;

            /**
            * 当客户端发来消息时触发
            *
            * @param int   $client_id 连接id
            * @param mixed $message   具体消息
            */
            public static function onMessage($clientId, $message)
            &#123;
                Log::info(&#39;socket_message==&#39; . $message);
                Log::info(&#39;$clientId==&#39; . $clientId);
                $data = json_decode($message, true);
                $sendUserId = $data[&#39;user_id&#39;];
                Log::info($data);
                $token = $data[&#39;token&#39;];
                if (isset($data[&#39;send&#39;])) &#123;
                    $recipientUserId = $data[&#39;recipient_user_id&#39;];
                    $toClientId = static::getUserClientId($recipientUserId);
                    Log::info(&#39;$toClientId==&#39; . $toClientId);
                    $isOnline = Gateway::isOnline($toClientId);

                    //数据库消息存储操作

                    //toClientId exist and online and create success
                    if (!empty($toClientId) and $isOnline and $result[&#39;status&#39;]) &#123;
                        //给发送方，发送一条消息
                        Gateway::sendToClient(
                            $clientId,
                            json_encode([&#39;type&#39; =&gt; &#39;send&#39;, &#39;status&#39; =&gt; &#39;OK&#39;, &#39;messages&#39; =&gt; $result[&#39;data&#39;]])
                        );
                        //给接收方发送一条消息
                        Gateway::sendToClient(
                            $toClientId,
                            json_encode([&#39;type&#39; =&gt; &#39;recipient&#39;, &#39;status&#39; =&gt; &#39;OK&#39;, &#39;messages&#39; =&gt; $result[&#39;data&#39;]])
                        );
                    &#125; else &#123;
                        Gateway::sendToClient(
                            $clientId,
                            json_encode([&#39;status&#39; =&gt; &#39;FAIL&#39;, &#39;messages&#39; =&gt; &#39;toClientId不存在或者不在线&#39;])
                        );
                    &#125;
                &#125; else &#123;
                    static::updateUserMessageToken($sendUserId, $token);
                    // Gateway::bindUid($clientId, $sendUserId);
                    static::setClientId($token, $clientId);
                &#125;
            &#125;

            /**
            * 当用户断开连接时触发
            *
            * @param int $client_id 连接id
            */
            public static function onClose($clientId)
            &#123;
                Log::info(&#39;socket_message:断开连接&#39;);
            &#125;
        &#125;
        页面调用：

        const webSocket = new WebSocket(&#39;ws://localhost&#39;);

        // set clientId
        webSocket.onopen = () =&gt; &#123;
            console.log(&#39;start set client_id&#39;);
            console.log(&#39;token===&#39; + token);
            webSocket.send(stringify(&#123; &#39;token&#39;: token, &#39;user_id&#39;: sendUserId &#125;));
        &#125;
        webSocket.onmessage=(message)=&gt; &#123;
            //get info show on client
            console.log(message);
            if (message &amp;&amp; message.data) &#123;
                        //按照发送的数据结构进行处理即可

                  &#125;

        &#125;
</code></pre>
]]></content>
      <categories>
        <category>laravel workman websocket php</category>
      </categories>
  </entry>
  <entry>
    <title>[Android]实现更换网络图片,并且设置圆角</title>
    <url>/2016/10/28/%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%8D%A2%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87,%E5%B9%B6%E4%B8%94%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/</url>
    <content><![CDATA[<pre><code>new DownloadImageTask(airport_image)
        .execute(image);  //image即是获取到的图片url
</code></pre>
<p>   private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; {<br>        ImageView bmImage;</p>
<pre><code>    public DownloadImageTask(ImageView bmImage) &#123;
        this.bmImage = bmImage;
    &#125;

    protected Bitmap doInBackground(String... urls) &#123;
        String urldisplay = urls[0];
        Bitmap mIcon11 = null;
        try &#123;
            InputStream in = new java.net.URL(urldisplay).openStream();
            mIcon11 = BitmapFactory.decodeStream(in);
        &#125; catch (Exception e) &#123;
            Log.e(&quot;Error&quot;, e.getMessage());
            e.printStackTrace();
        &#125;
        return mIcon11;
    &#125;

    protected void onPostExecute(Bitmap mbitmap) &#123;
        Bitmap imageRounded = Bitmap.createBitmap(mbitmap.getWidth(), mbitmap.getHeight(), mbitmap.getConfig());
        Canvas canvas = new Canvas(imageRounded);
        Paint mpaint = new Paint();
        mpaint.setAntiAlias(true);
        mpaint.setShader(new BitmapShader(mbitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));
        canvas.drawRoundRect((new RectF(0, 0, mbitmap.getWidth(), mbitmap.getHeight())), 50, 50, mpaint);// Round Image Corner 100 100 100 100
        bmImage.setImageBitmap(imageRounded);
</code></pre>
<p>   &#x2F;&#x2F;       bmImage.setImageBitmap(result);<br>            Log.d(TAG, “设置&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;onPostExecute”);<br>        }<br>    }</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>[android] 支付宝app支付android篇</title>
    <url>/2017/05/04/%E6%94%AF%E4%BB%98%E5%AE%9Dapp%E6%94%AF%E4%BB%98android%E7%AF%87/</url>
    <content><![CDATA[<pre><code>    /**********************************配置部分AndroidManifest.xml************************************/
    权限配置参考官网api文档

    &lt;!-- alipay sdk begin --&gt;
    &lt;activity
            android:name=&quot;com.alipay.sdk.app.H5PayActivity&quot;
            android:configChanges=&quot;orientation|keyboardHidden|navigation|screenSize&quot;
            android:exported=&quot;false&quot;
            android:screenOrientation=&quot;behind&quot;
            android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot; &gt;
    &lt;/activity&gt;
    &lt;activity
            android:name=&quot;com.alipay.sdk.app.H5AuthActivity&quot;
            android:configChanges=&quot;orientation|keyboardHidden|navigation&quot;
            android:exported=&quot;false&quot;
            android:screenOrientation=&quot;behind&quot;
            android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot; &gt;
    &lt;/activity&gt;

    &lt;!-- alipay sdk end --&gt;

    /**********************************支付部分************************************/

    h5需要实现一个function global_function_alipay_pay()返回请求接口的地址: http://api.***.com/interface/payments/alipay?order_id=1，
    点击支付请求***/zhi_fu_bao_pay

    //android拦截
    pattern = Pattern.compile(&quot;zhi_fu_bao_pay&quot;);
    matcher = pattern.matcher(url);
    if(matcher.find()) &#123;
            Log.d(TAG, &quot;confirm order 支付宝开始支付&quot;);
            shopShowWebView.evaluateJavascript(&quot;global_function_alipay_pay()&quot;, new ValueCallback&lt;String&gt;() &#123;
                  @Override
                  public void onReceiveValue(String value) &#123;
                      if(!value.contains(&quot;null&quot;) &amp;&amp; !value.contains(&quot;NULL&quot;)) &#123;
                          Log.d(TAG, &quot;运行到了这里,开始支付宝支付=====&quot; + value);
                          String payUrl = translateHtmlStringToLocal(value);

                          getAlipayInfoFromServer(payUrl);
                      &#125;
                  &#125;&#125;);
            return true;
    &#125;

    /**
     * 获取支付宝支付信息
     * @param payUrl
     * @return
     */
    protected AlipayBean getAlipayInfoFromServer(final String payUrl) &#123;

            final AlipayBean[] alipayBean = &#123;new AlipayBean()&#125;;

            if (this != null) &#123;
                    this.showLoadingDialog();
            &#125;
            com.lidroid.xutils.HttpUtils http = new com.lidroid.xutils.HttpUtils();
            http.send(HttpRequest.HttpMethod.POST,
                          payUrl,
                          null,
                          new RequestCallBack&lt;String&gt;() &#123;
                              @Override
                              public void onSuccess(ResponseInfo&lt;String&gt; responseInfo) &#123;

                                  if (ShopShowActivity.this != null) &#123;
                                      ShopShowActivity.this.dismissLoadingDialog();
                                  &#125;
                                  if (responseInfo != null &amp;&amp; responseInfo.result != null) &#123;
                                      Log.d(TAG, &quot;=========获取到的responseInfo.result为===&quot; + responseInfo.result + &quot;=========&quot;);
                                      alipayBean[0] = JSON.parseObject(responseInfo.result, AlipayBean.class);

                                      alipay(alipayBean[0]);
                                  &#125; else &#123;
                                      if (ShopShowActivity.this != null) &#123;
                                          Toast.makeText(ShopShowActivity.this, &quot;获取支付信息失败&quot;, Toast.LENGTH_SHORT).show();
                                      &#125;
                                  &#125;
                              &#125;

                              @Override
                              public void onFailure(HttpException e, String s) &#123;
                                  Log.d(TAG, &quot;=========onFailure(HttpException e, String s)&quot; + s + &quot;============&quot; + e.toString());

                                  if (ShopShowActivity.this != null) &#123;
                                      ShopShowActivity.this.dismissLoadingDialog();
                                  &#125;
                                  e.printStackTrace();
                              &#125;
                          &#125;);
            return alipayBean[0];
    &#125;

    /**
     * 支付宝支付方法
     * @param alipayBean
     */
    public void alipay(final AlipayBean alipayBean) &#123;

            Map&lt;String, String&gt; params = OrderInfoUtil2_0.buildOrderParamMap(alipayBean);
            String orderParam = OrderInfoUtil2_0.buildOrderParam(params);
            String sign = OrderInfoUtil2_0.getSign(params, alipayBean.getSign());
    //        String sign = OrderInfoUtil2_0.getSign(params, RSA_PRIVATE);
            final String orderInfo = orderParam + &quot;&amp;&quot; + sign;

            /**
             * 完整的符合支付宝参数规范的订单信息
             */
    //            final String payInfo = info + &quot;&amp;&quot; + sign;

    //            PayTask alipay = new PayTask(getActivity());
    //            String result = alipay.pay(payInfo, true); // 调用支付接口进行支付

            Log.d(TAG, &quot;==========orderInfo=============&quot; + orderInfo);
            Runnable payRunnable = new Runnable() &#123;
                    @Override
                    public void run() &#123;

                          //for android 6.0
                          if (ActivityCompat.checkSelfPermission(ShopShowActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123;
                              Log.d(TAG, &quot;== in android 6.0, getting permission&quot;);
                              ActivityCompat.requestPermissions(ShopShowActivity.this, new String[]&#123;Manifest.permission.READ_PHONE_STATE&#125;, 1);
                          &#125;

                          PayTask payTask = new PayTask(ShopShowActivity.this);
                          Map&lt;String, String&gt; result = payTask.payV2(orderInfo, true);

                          Log.d(TAG, &quot;=================result===&quot; + result.toString());

                          Message msg = new Message();
                          msg.what = SDK_PAY_FLAG;
                          msg.obj = result;
                          handler.sendMessage(msg);
                    &#125;
            &#125;;

            Thread payThread = new Thread(payRunnable);
            payThread.start();
    &#125;

    /*
     * 接收消息, 能触发对应的方法
     */
    private Handler handler = new Handler() &#123;
            @TargetApi(Build.VERSION_CODES.KITKAT)
            @Override
            public void handleMessage(Message msg) &#123;
                    switch (msg.what) &#123;
                          case SDK_PAY_FLAG: &#123;
                              Log.d(TAG, &quot;======|||||||||||||||||||||..................&quot;);
                              Log.d(TAG, msg.obj.toString());

                              PayResult payResult = new PayResult((Map&lt;String, String&gt;) msg.obj);

                              /**
                               * 同步返回的结果必须放置到服务端进行验证，建议商户依赖异步通知
                               */
                              String resultInfo = payResult.getResult();// 同步返回需要验证的信息

                              Log.d(TAG, &quot;=====alipay resultInfo====&quot; + resultInfo);

                              final String resultStatus = payResult.getResultStatus();

                              Log.d(TAG, &quot;=====alipay resultStatus====&quot; + resultStatus);

                              shopShowWebView.evaluateJavascript(&quot;getPayOrderId()&quot;, new ValueCallback&lt;String&gt;() &#123;
                                  @Override
                                  public void onReceiveValue(String value) &#123;
                                      Log.d(TAG, &quot;getPayOrderId value=&quot; + value);
                                      if(!value.contains(&quot;null&quot;) &amp;&amp; !value.contains(&quot;NULL&quot;)) &#123;

                                          Log.d(TAG, &quot;运行到了这里getPayOrderId()===支付的订单id为=========&quot; + value);
                                          // 判断resultStatus 为“9000”则代表支付成功，具体状态码代表含义可参考接口文档
                                          if (TextUtils.equals(resultStatus, &quot;9000&quot;)) &#123;
                                              Toast.makeText(ShopShowActivity.this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show();

                                              Intent intent = new Intent(ShopShowActivity.this, PaySuccessActivity.class);
                                              intent.putExtra(&quot;id&quot;, value);
                                              startActivity(intent);
                                              finish();
                                          &#125; else &#123;
                                              // 判断resultStatus 为非&quot;9000&quot;则代表可能支付失败
                                              // &quot;8000&quot;代表支付结果因为支付渠道原因或者系统原因还在等待支付结果确认，最终交易是否成功以服务端异步通知为准（小概率状态）
                                              if (TextUtils.equals(resultStatus, &quot;8000&quot;)) &#123;
                                                  Toast.makeText(ShopShowActivity.this, &quot;支付结果确认中&quot;, Toast.LENGTH_SHORT).show();
                                              &#125; else &#123;
                                                  // 其他值就可以判断为支付失败，包括用户主动取消支付，或者系统返回的错误
                                                  Toast.makeText(ShopShowActivity.this, &quot;支付失败&quot;, Toast.LENGTH_SHORT).show();
                                              &#125;
                                              Intent intent = new Intent(ShopShowActivity.this, PayFailActivity.class);
                                              intent.putExtra(&quot;id&quot;, value);
                                              startActivity(intent);
                                              finish();

                                          &#125;
                                      &#125;
                                  &#125;&#125;);
                              break;
                          &#125;
                    &#125;
            &#125;;
    &#125;;


    /**************************下面都是支付宝支付工具类****************************/
    package com.***.utils;

    public final class Base64 &#123;

        private static final int BASELENGTH = 128;
        private static final int LOOKUPLENGTH = 64;
        private static final int TWENTYFOURBITGROUP = 24;
        private static final int EIGHTBIT = 8;
        private static final int SIXTEENBIT = 16;
        private static final int FOURBYTE = 4;
        private static final int SIGN = -128;
        private static char PAD = &#39;=&#39;;
        private static byte[] base64Alphabet = new byte[BASELENGTH];
        private static char[] lookUpBase64Alphabet = new char[LOOKUPLENGTH];

        static &#123;
            for (int i = 0; i &lt; BASELENGTH; ++i) &#123;
                base64Alphabet[i] = -1;
            &#125;
            for (int i = &#39;Z&#39;; i &gt;= &#39;A&#39;; i--) &#123;
                base64Alphabet[i] = (byte) (i - &#39;A&#39;);
            &#125;
            for (int i = &#39;z&#39;; i &gt;= &#39;a&#39;; i--) &#123;
                base64Alphabet[i] = (byte) (i - &#39;a&#39; + 26);
            &#125;

            for (int i = &#39;9&#39;; i &gt;= &#39;0&#39;; i--) &#123;
                base64Alphabet[i] = (byte) (i - &#39;0&#39; + 52);
            &#125;

            base64Alphabet[&#39;+&#39;] = 62;
            base64Alphabet[&#39;/&#39;] = 63;

            for (int i = 0; i &lt;= 25; i++) &#123;
                lookUpBase64Alphabet[i] = (char) (&#39;A&#39; + i);
            &#125;

            for (int i = 26, j = 0; i &lt;= 51; i++, j++) &#123;
                lookUpBase64Alphabet[i] = (char) (&#39;a&#39; + j);
            &#125;

            for (int i = 52, j = 0; i &lt;= 61; i++, j++) &#123;
                lookUpBase64Alphabet[i] = (char) (&#39;0&#39; + j);
            &#125;
            lookUpBase64Alphabet[62] = (char) &#39;+&#39;;
            lookUpBase64Alphabet[63] = (char) &#39;/&#39;;

        &#125;

        private static boolean isWhiteSpace(char octect) &#123;
            return (octect == 0x20 || octect == 0xd || octect == 0xa || octect == 0x9);
        &#125;

        private static boolean isPad(char octect) &#123;
            return (octect == PAD);
        &#125;

        private static boolean isData(char octect) &#123;
            return (octect &lt; BASELENGTH &amp;&amp; base64Alphabet[octect] != -1);
        &#125;

        /**
         * Encodes hex octects into Base64
         *
         * @param binaryData
         *            Array containing binaryData
         * @return Encoded Base64 array
         */
        public static String encode(byte[] binaryData) &#123;

            if (binaryData == null) &#123;
                return null;
            &#125;

            int lengthDataBits = binaryData.length * EIGHTBIT;
            if (lengthDataBits == 0) &#123;
                return &quot;&quot;;
            &#125;

            int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;
            int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;
            int numberQuartet = fewerThan24bits != 0 ? numberTriplets + 1
                    : numberTriplets;
            char encodedData[] = null;

            encodedData = new char[numberQuartet * 4];

            byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;

            int encodedIndex = 0;
            int dataIndex = 0;

            for (int i = 0; i &lt; numberTriplets; i++) &#123;
                b1 = binaryData[dataIndex++];
                b2 = binaryData[dataIndex++];
                b3 = binaryData[dataIndex++];

                l = (byte) (b2 &amp; 0x0f);
                k = (byte) (b1 &amp; 0x03);

                byte val1 = ((b1 &amp; SIGN) == 0) ? (byte) (b1 &gt;&gt; 2)
                        : (byte) ((b1) &gt;&gt; 2 ^ 0xc0);
                byte val2 = ((b2 &amp; SIGN) == 0) ? (byte) (b2 &gt;&gt; 4)
                        : (byte) ((b2) &gt;&gt; 4 ^ 0xf0);
                byte val3 = ((b3 &amp; SIGN) == 0) ? (byte) (b3 &gt;&gt; 6)
                        : (byte) ((b3) &gt;&gt; 6 ^ 0xfc);

                encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
                encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];
                encodedData[encodedIndex++] = lookUpBase64Alphabet[(l &lt;&lt; 2) | val3];
                encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 &amp; 0x3f];
            &#125;

            // form integral number of 6-bit groups
            if (fewerThan24bits == EIGHTBIT) &#123;
                b1 = binaryData[dataIndex];
                k = (byte) (b1 &amp; 0x03);

                byte val1 = ((b1 &amp; SIGN) == 0) ? (byte) (b1 &gt;&gt; 2)
                        : (byte) ((b1) &gt;&gt; 2 ^ 0xc0);
                encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
                encodedData[encodedIndex++] = lookUpBase64Alphabet[k &lt;&lt; 4];
                encodedData[encodedIndex++] = PAD;
                encodedData[encodedIndex++] = PAD;
            &#125; else if (fewerThan24bits == SIXTEENBIT) &#123;
                b1 = binaryData[dataIndex];
                b2 = binaryData[dataIndex + 1];
                l = (byte) (b2 &amp; 0x0f);
                k = (byte) (b1 &amp; 0x03);

                byte val1 = ((b1 &amp; SIGN) == 0) ? (byte) (b1 &gt;&gt; 2)
                        : (byte) ((b1) &gt;&gt; 2 ^ 0xc0);
                byte val2 = ((b2 &amp; SIGN) == 0) ? (byte) (b2 &gt;&gt; 4)
                        : (byte) ((b2) &gt;&gt; 4 ^ 0xf0);

                encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
                encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];
                encodedData[encodedIndex++] = lookUpBase64Alphabet[l &lt;&lt; 2];
                encodedData[encodedIndex++] = PAD;
            &#125;

            return new String(encodedData);
        &#125;

        /**
         * Decodes Base64 data into octects
         *
         * @param encoded
         *            string containing Base64 data
         * @return Array containind decoded data.
         */
        public static byte[] decode(String encoded) &#123;

            if (encoded == null) &#123;
                return null;
            &#125;

            char[] base64Data = encoded.toCharArray();
            // remove white spaces
            int len = removeWhiteSpace(base64Data);

            if (len % FOURBYTE != 0) &#123;
                return null;// should be divisible by four
            &#125;

            int numberQuadruple = (len / FOURBYTE);

            if (numberQuadruple == 0) &#123;
                return new byte[0];
            &#125;

            byte decodedData[] = null;
            byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;
            char d1 = 0, d2 = 0, d3 = 0, d4 = 0;

            int i = 0;
            int encodedIndex = 0;
            int dataIndex = 0;
            decodedData = new byte[(numberQuadruple) * 3];

            for (; i &lt; numberQuadruple - 1; i++) &#123;

                if (!isData((d1 = base64Data[dataIndex++]))
                        || !isData((d2 = base64Data[dataIndex++]))
                        || !isData((d3 = base64Data[dataIndex++]))
                        || !isData((d4 = base64Data[dataIndex++]))) &#123;
                    return null;
                &#125;// if found &quot;no data&quot; just return null

                b1 = base64Alphabet[d1];
                b2 = base64Alphabet[d2];
                b3 = base64Alphabet[d3];
                b4 = base64Alphabet[d4];

                decodedData[encodedIndex++] = (byte) (b1 &lt;&lt; 2 | b2 &gt;&gt; 4);
                decodedData[encodedIndex++] = (byte) (((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf));
                decodedData[encodedIndex++] = (byte) (b3 &lt;&lt; 6 | b4);
            &#125;

            if (!isData((d1 = base64Data[dataIndex++]))
                    || !isData((d2 = base64Data[dataIndex++]))) &#123;
                return null;// if found &quot;no data&quot; just return null
            &#125;

            b1 = base64Alphabet[d1];
            b2 = base64Alphabet[d2];

            d3 = base64Data[dataIndex++];
            d4 = base64Data[dataIndex++];
            if (!isData((d3)) || !isData((d4))) &#123;// Check if they are PAD characters
                if (isPad(d3) &amp;&amp; isPad(d4)) &#123;
                    if ((b2 &amp; 0xf) != 0)// last 4 bits should be zero
                    &#123;
                        return null;
                    &#125;
                    byte[] tmp = new byte[i * 3 + 1];
                    System.arraycopy(decodedData, 0, tmp, 0, i * 3);
                    tmp[encodedIndex] = (byte) (b1 &lt;&lt; 2 | b2 &gt;&gt; 4);
                    return tmp;
                &#125; else if (!isPad(d3) &amp;&amp; isPad(d4)) &#123;
                    b3 = base64Alphabet[d3];
                    if ((b3 &amp; 0x3) != 0)// last 2 bits should be zero
                    &#123;
                        return null;
                    &#125;
                    byte[] tmp = new byte[i * 3 + 2];
                    System.arraycopy(decodedData, 0, tmp, 0, i * 3);
                    tmp[encodedIndex++] = (byte) (b1 &lt;&lt; 2 | b2 &gt;&gt; 4);
                    tmp[encodedIndex] = (byte) (((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf));
                    return tmp;
                &#125; else &#123;
                    return null;
                &#125;
            &#125; else &#123; // No PAD e.g 3cQl
                b3 = base64Alphabet[d3];
                b4 = base64Alphabet[d4];
                decodedData[encodedIndex++] = (byte) (b1 &lt;&lt; 2 | b2 &gt;&gt; 4);
                decodedData[encodedIndex++] = (byte) (((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf));
                decodedData[encodedIndex++] = (byte) (b3 &lt;&lt; 6 | b4);

            &#125;

            return decodedData;
        &#125;

        /**
         * remove WhiteSpace from MIME containing encoded Base64 data.
         *
         * @param data
         *            the byte array of base64 data (with WS)
         * @return the new length
         */
        private static int removeWhiteSpace(char[] data) &#123;
            if (data == null) &#123;
                return 0;
            &#125;

            // count characters that&#39;s not whitespace
            int newSize = 0;
            int len = data.length;
            for (int i = 0; i &lt; len; i++) &#123;
                if (!isWhiteSpace(data[i])) &#123;
                    data[newSize++] = data[i];
                &#125;
            &#125;
            return newSize;
        &#125;
    &#125;


    package com.***.utils;

    import android.util.Log;

    import com.alibaba.fastjson.JSON;
    import com.syyj.javabean.AlipayBean;

    import org.json.JSONObject;

    import java.io.UnsupportedEncodingException;
    import java.net.URLEncoder;
    import java.text.SimpleDateFormat;
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.Date;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Locale;
    import java.util.Map;
    import java.util.Random;


    public class OrderInfoUtil2_0 &#123;

        /**
         * 构造授权参数列表
         * 
         * @param pid
         * @param app_id
         * @param target_id
         * @return
         */
        public static Map&lt;String, String&gt; buildAuthInfoMap(String pid, String app_id, String target_id) &#123;
            Map&lt;String, String&gt; keyValues = new HashMap&lt;String, String&gt;();

            // 商户签约拿到的app_id，如：2013081700024223
            keyValues.put(&quot;app_id&quot;, app_id);

            // 商户签约拿到的pid，如：2088102123816631
            keyValues.put(&quot;pid&quot;, pid);

            // 服务接口名称， 固定值
            keyValues.put(&quot;apiname&quot;, &quot;com.alipay.account.auth&quot;);

            // 商户类型标识， 固定值
            keyValues.put(&quot;app_name&quot;, &quot;mc&quot;);

            // 业务类型， 固定值
            keyValues.put(&quot;biz_type&quot;, &quot;openservice&quot;);

            // 产品码， 固定值
            keyValues.put(&quot;product_id&quot;, &quot;APP_FAST_LOGIN&quot;);

            // 授权范围， 固定值
            keyValues.put(&quot;scope&quot;, &quot;kuaijie&quot;);

            // 商户唯一标识，如：kkkkk091125
            keyValues.put(&quot;target_id&quot;, target_id);

            // 授权类型， 固定值
            keyValues.put(&quot;auth_type&quot;, &quot;AUTHACCOUNT&quot;);

            // 签名类型
            keyValues.put(&quot;sign_type&quot;, &quot;RSA&quot;);

            return keyValues;
        &#125;

        /**
         * 构造支付订单参数列表
         */
        public static Map&lt;String, String&gt; buildOrderParamMap(AlipayBean alipayBean) &#123;
            Map&lt;String, String&gt; keyValues = new HashMap&lt;String, String&gt;();

            keyValues.put(&quot;app_id&quot;, alipayBean.getApp_id());

            Log.d(&quot;OrderInfoUtil2_0&quot;, &quot;=======biz_content_json=======&quot; + JSON.toJSONString(alipayBean.getBit_content_json()));

            keyValues.put(&quot;biz_content&quot;, alipayBean.getBit_content_json());

            keyValues.put(&quot;charset&quot;, alipayBean.getCharset());

            keyValues.put(&quot;method&quot;, alipayBean.getMethod());

            keyValues.put(&quot;sign_type&quot;, alipayBean.getSign_type());

            Log.d(&quot;OrderInfoUtil2_0&quot;, &quot;===========curDate=======&quot; + alipayBean.getTimestamp());
            keyValues.put(&quot;timestamp&quot;, alipayBean.getTimestamp());
    //
            keyValues.put(&quot;version&quot;, alipayBean.getVersion());

            Log.d(&quot;OrderInfoUtil2_0&quot;, &quot;notify_url===========&quot; + alipayBean.getNotify_url());

            keyValues.put(&quot;notify_url&quot;, alipayBean.getNotify_url());

            return keyValues;
        &#125;

        /**
         * 构造支付订单参数信息
         * 
         * @param map
         * 支付订单参数
         * @return
         */
        public static String buildOrderParam(Map&lt;String, String&gt; map) &#123;
            List&lt;String&gt; keys = new ArrayList&lt;String&gt;(map.keySet());
            //这句是后来添加的
            Collections.sort(keys);

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i &lt; keys.size() - 1; i++) &#123;
                String key = keys.get(i);
                String value = map.get(key);
                sb.append(buildKeyValue(key, value, true));
                sb.append(&quot;&amp;&quot;);
            &#125;

            String tailKey = keys.get(keys.size() - 1);
            String tailValue = map.get(tailKey);
            sb.append(buildKeyValue(tailKey, tailValue, true));

            return sb.toString();
        &#125;

        /**
         * 拼接键值对
         * 
         * @param key
         * @param value
         * @param isEncode
         * @return
         */
        private static String buildKeyValue(String key, String value, boolean isEncode) &#123;
            StringBuilder sb = new StringBuilder();
            sb.append(key);
            sb.append(&quot;=&quot;);
            if (isEncode) &#123;
                try &#123;
                    sb.append(URLEncoder.encode(value, &quot;UTF-8&quot;));
                &#125; catch (UnsupportedEncodingException e) &#123;
                    sb.append(value);
                &#125;
            &#125; else &#123;
                sb.append(value);
            &#125;
            return sb.toString();
        &#125;

        /**
         * 对支付参数信息进行签名
         * 
         * @param map
         * 待签名授权信息
         * 
         * @return
         */
        public static String getSign(Map&lt;String, String&gt; map, String rsaKey) &#123;
            List&lt;String&gt; keys = new ArrayList&lt;String&gt;(map.keySet());
            // key排序
            Collections.sort(keys);

            Log.d(&quot;OrderInfoUtil2_0&quot;, &quot;===========================sort keys.toString()============&quot; + keys.toString());

            StringBuilder authInfo = new StringBuilder();
            for (int i = 0; i &lt; keys.size() - 1; i++) &#123;
                String key = keys.get(i);
                String value = map.get(key);
                authInfo.append(buildKeyValue(key, value, false));
                authInfo.append(&quot;&amp;&quot;);
            &#125;

            String tailKey = keys.get(keys.size() - 1);
            String tailValue = map.get(tailKey);
            authInfo.append(buildKeyValue(tailKey, tailValue, false));

            String oriSign = SignUtils.sign(authInfo.toString(), rsaKey);
            String encodedSign = &quot;&quot;;

            try &#123;
                encodedSign = URLEncoder.encode(oriSign, &quot;UTF-8&quot;);
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;

            Log.d(&quot;OrderInfoUtil2_0&quot;, &quot;最终签名为:===sign=&quot; + encodedSign);

            return &quot;sign=&quot; + encodedSign;
        &#125;

        /**
         * 使用内部生成的订单号，不使用该方法生成了
         * 要求外部订单号必须唯一。
         * @return
         */
        private static String getOutTradeNo() &#123;
            SimpleDateFormat format = new SimpleDateFormat(&quot;MMddHHmmss&quot;, Locale.getDefault());
            Date date = new Date();
            String key = format.format(date);

            Random r = new Random();
            key = key + r.nextInt();
            key = key.substring(0, 15);
            return key;
        &#125;

    &#125;



    package com.***.utils;


    import java.util.Map;

    import android.text.TextUtils;

    public class PayResult &#123;
            private String resultStatus;
            private String result;
            private String memo;

            public PayResult(Map&lt;String, String&gt; rawResult) &#123;
                    if (rawResult == null) &#123;
                          return;
                    &#125;

                    for (String key : rawResult.keySet()) &#123;
                          if (TextUtils.equals(key, &quot;resultStatus&quot;)) &#123;
                              resultStatus = rawResult.get(key);
                          &#125; else if (TextUtils.equals(key, &quot;result&quot;)) &#123;
                              result = rawResult.get(key);
                          &#125; else if (TextUtils.equals(key, &quot;memo&quot;)) &#123;
                              memo = rawResult.get(key);
                          &#125;
                    &#125;
            &#125;

            @Override
            public String toString() &#123;
                    return &quot;resultStatus=&#123;&quot; + resultStatus + &quot;&#125;;memo=&#123;&quot; + memo
                              + &quot;&#125;;result=&#123;&quot; + result + &quot;&#125;&quot;;
            &#125;

            /**
             * @return the resultStatus
             */
            public String getResultStatus() &#123;
                    return resultStatus;
            &#125;

            /**
             * @return the memo
             */
            public String getMemo() &#123;
                    return memo;
            &#125;

            /**
             * @return the result
             */
            public String getResult() &#123;
                    return result;
            &#125;
    &#125;


    package com.***.utils;

    import java.security.KeyFactory;
    import java.security.PrivateKey;
    import java.security.spec.PKCS8EncodedKeySpec;

    public class SignUtils &#123;

        private static final String ALGORITHM = &quot;RSA&quot;;

        private static final String SIGN_ALGORITHMS = &quot;SHA1WithRSA&quot;;

        private static final String DEFAULT_CHARSET = &quot;UTF-8&quot;;

        public static String sign(String content, String privateKey) &#123;
            try &#123;
                PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(
                        Base64.decode(privateKey));
                KeyFactory keyf = KeyFactory.getInstance(ALGORITHM);
                PrivateKey priKey = keyf.generatePrivate(priPKCS8);

                java.security.Signature signature = java.security.Signature
                        .getInstance(SIGN_ALGORITHMS);

                signature.initSign(priKey);
                signature.update(content.getBytes(DEFAULT_CHARSET));

                byte[] signed = signature.sign();

                return Base64.encode(signed);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

            return null;
        &#125;

    &#125;
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>[Ruby on Rails] 支付宝app支付接口篇</title>
    <url>/2017/04/20/%E6%94%AF%E4%BB%98%E5%AE%9Dapp%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3%E7%AF%87/</url>
    <content><![CDATA[<pre><code>    两个action都是post请求，在routes配置好。


    def alipay

      @order = Order.includes(:good).find(params[:order_id])
      biz_content = &#123;
          timeout_express: &quot;30m&quot;,
          product_code: &quot;QUICK_MSECURITY_PAY&quot;,
          total_amount: @order.buy_count * @order.amount,
          subject: &quot;#&#123;@order.good.name&#125; x #&#123;@order.buy_count&#125;&quot;,
          body: &quot;#&#123;params[:order_id]&#125;&quot;,
          out_trade_no: @order.order_number,
        &#125;

      result = &#123;
        :app_id     =&gt; Settings.alipay.app_id,
        :method     =&gt; &quot;alipay.trade.app.pay&quot;,
        :charset    =&gt; &quot;utf-8&quot;,
        :sign_type  =&gt; &quot;RSA&quot;,
        :sign       =&gt; &quot;your pkcs8格式的private key，使用openssl生成的，供android调用&quot;,
        :timestamp   =&gt; Time.now.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;),
        :version     =&gt; &quot;1.0&quot;,
        :notify_url  =&gt; &quot;http://api.×××××.com/interface/payments/alipay_notify&quot;,
        :bit_content =&gt; biz_content,
        :bit_content_json =&gt; biz_content.to_json
      &#125;
      render json: result

    end

    #回调方法
    def alipay_notify
      notify_params = params.except(*request.path_parameters.keys)
      Rails.logger.info &quot;支付宝回调结果：&quot;
      Rails.logger.info notify_params
      verify_result = Alipay::Notify.verify?(notify_params)
      Rails.logger.info verify_result
      Rails.logger.info &quot;==  order_id ========== #&#123;notify_params[&#39;body&#39;].to_i&#125;----&quot;

      # 应该判断 verify_result 但是不知道为什么每次都确认失败
      # 请查看 https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.yfSIXP&amp;treeId=193&amp;articleId=105301&amp;docType=1

      if true
        @order = Order.find(notify_params[&#39;body&#39;].to_i)
        begin
          unless @order.blank?
            Rails.logger.info &quot;==  order is not blank !!!!!----&quot;
            time = Time.now.to_datetime
            @order.update_attributes(:order_status =&gt; &#39;yizhifu&#39;, :collect =&gt; notify_params[&#39;total_amount&#39;], :payed_at =&gt; time)
          else
            Rails.logger.info &quot;==  order is blank !!!!!----&quot;
            Rails.logger.info @order.errors
          end
                render :json =&gt; &#123; return_code: &quot;success&quot; &#125;
        rescue &#39;&#39;
          Rails.logger.error &#39;order pay error&#39;
                render :json =&gt; &#123; return_code: &quot;fail&quot;, return_msg: &quot;&quot; &#125;
        end
      else
            render :json =&gt; &#123; return_code: &quot;fail&quot;, return_msg: &quot;&quot; &#125;
      end
    end
</code></pre>
]]></content>
      <categories>
        <category>Ruby on Rails</category>
      </categories>
  </entry>
  <entry>
    <title>[Ubuntu] 支付宝支付使用openssl生成key</title>
    <url>/2017/04/10/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E4%BD%BF%E7%94%A8openssl%E7%94%9F%E6%88%90key/</url>
    <content><![CDATA[<pre><code>    支付宝支付使用openssl生成公钥，私钥，pkcs8格式密钥


    #打开openssl
    openssl

    #生成私钥
    genrsa -out rsa_private_key.pem 2048

    #转换私钥格式为pkcs8格式
    pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out rsa_private_key_pkcs8.pem

    #生成公钥
    rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem

    生成的3个.pem文件会在当前文件夹下,使用cat命令打开。公钥填写到支付宝开放平台，私钥填写在接口处，供app调用。
</code></pre>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>[JavaScript]禁用鼠标右键的“粘贴”菜单，可以防止鼠标右键或者Ctrl + V粘贴不合法的数据</title>
    <url>/2014/04/25/%E7%A6%81%E6%AD%A2%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E7%B2%98%E8%B4%B4%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<pre><code class="bash">onpaste=&quot;javascript: return false;&quot;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
</search>
